/******************************************************************************
BigWorld Technology
Copyright BigWorld Pty, Ltd.
All Rights Reserved. Commercial in confidence.

WARNING: This computer program is protected by copyright law and international
treaties. Unauthorized use, reproduction or distribution of this program, or
any portion of this program, may result in the imposition of civil and
criminal penalties as provided by law.
******************************************************************************/

#include "Python.h"		// See http://docs.python.org/api/includes.html

#include "logger.hpp"

#include "cstdmf/debug.hpp"
#include "network/mercury.hpp"
#include "network/portmap.hpp"
#include "network/logger_message_forwarder.hpp"
#include "server/bwconfig.hpp"
#include "server/bwservice.hpp"

#include <algorithm>
#include <time.h>

#ifdef _WIN32
#define snprintf _snprintf
#endif

#ifdef _WIN32
#define unlink _unlink
#endif

#ifdef unix
#include "pwd.h"
#endif

DECLARE_DEBUG_COMPONENT( 0 )

extern bool g_shouldWriteToConsole;
extern bool g_shouldWriteTimePrefix;

static const char * USAGE_MESSAGE =
	"\n"
	"Usage: logger [options] [outdir]\n"
	"options:\n"
	" -h, --help    Print this message and exit.\n"
	" -u UID        Log only messages from processes run by the user\n"
	"                with uid = UID. If UID is \"all\", messages from\n"
	"                all users will be logged. If no uid is specified,\n"
	"                processes by all users will be logged.\n"
	" -p NAME       Log messages from processes with name NAME. Multiple\n"
	"                names may be specified using multiple -p options. By\n"
	"                default, messages from processes of any name are\n"
	"                logged. Appropriate names include: CellAppMgr, CellApp,\n"
	"                BaseApp, BaseAppMgr, DBMgr, LoginApp, WPGen. -p and\n"
	"                -d options can not be used at same time.\n"
	" -d NAME       Do not log messages from processes with name NAME.\n"
	"                Multiple names may be specified using multiple -d\n"
	"                options. By default messages from processes of any\n"
	"                name are logged. -d and -p options can not be used\n"
	"                at same time.\n"
	" -l LoggerID   If set, log only messages destined for this LoggerID\n"
	" -v            Verbose mode. Prints all messages to standard output.\n"
	" --daemon      Run as daemon\n"
	" -c|--config <conffile>\n"
	"               Specify config file to use.\n"
	" -t|--text     Generate 1.7-style text logs as well as binary logs\n"
	" -q|--quiet    Quiet Mode. Do not display message generated by this\n"
	"               process. By default, these are output to standard error.\n"
	" -o filename	Redirect standard output to filename.\n"
	" -e filename	Redirect standard error to filename.\n"
	" -[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|SCRIPT]\n"
	"               Disable logging of specific type of message.\n"
	" +[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|SCRIPT]\n"
	"               Enable logging of specific type of message. The first\n"
	"               option of this type disables logging of other messages.\n"
	"\n"
	"outdir         output will be stored in this directory\n";

// -----------------------------------------------------------------------------
// Section: Logger
// -----------------------------------------------------------------------------

namespace
{
	Logger * g_pInstance_;
}



/**
 *	Constructor.
 */
Logger::Logger() :
	StandardWatcherRequestHandler( watcherNub_ ),
	watcherNub_(),
	loggerID_( 0 ),
	logUser_( getUserId() ),
	logAllUsers_( true ),
	logNames_(),
	doNotLogNames_(),
	quietMode_( true ),
	daemonMode_( false ),
	shouldRoll_( false ),
	addLoggerData_(),
	delLoggerData_(),
	components_(),
	pLog_( new BWLog(), BWLogPtr::STEAL_REFERENCE )
{
	g_pInstance_ = this;

	for (int i = 0; i < NUM_MESSAGE_PRIORITY; ++i)
		shouldLogMessagePriority_[ i ] = true;

	MF_WATCH( "size", *this, &Logger::size );
	MF_WATCH( "reattachAll", *this,
			MF_ACCESSORS( bool, Logger, commandReattachAll ) );
	{
		MF_WATCH( "filter/threshold", DebugFilter::instance(),
				MF_ACCESSORS( int, DebugFilter, filterThreshold ) );
		MF_WATCH( "filter/TRACE",    shouldLogMessagePriority_[ 0 ] );
		MF_WATCH( "filter/DEBUG",    shouldLogMessagePriority_[ 1 ] );
		MF_WATCH( "filter/INFO",     shouldLogMessagePriority_[ 2 ] );
		MF_WATCH( "filter/NOTICE",   shouldLogMessagePriority_[ 3 ] );
		MF_WATCH( "filter/WARNING",  shouldLogMessagePriority_[ 4 ] );
		MF_WATCH( "filter/ERROR",    shouldLogMessagePriority_[ 5 ] );
		MF_WATCH( "filter/CRITICAL", shouldLogMessagePriority_[ 6 ] );
		MF_WATCH( "filter/HACK",     shouldLogMessagePriority_[ 7 ] );
		MF_WATCH( "filter/SCRIPT",   shouldLogMessagePriority_[ 8 ] );
	}

	Watcher::rootWatcher().addChild( "components",
		new MapWatcher< Components >( components_ ) );
	Watcher::rootWatcher().addChild( "components/*", &Component::watcher() );
}


/**
 *	This method initialises the logger.
 *
 *	@return True on success, otherwise false.
 */
bool Logger::init( int argc, char * argv[] )
{
	interfaceName_ = BWConfig::get(
		"message_logger/monitoringInterface",
		BWConfig::get( "monitoringInterface",
			Mercury::Nub::USE_BWMACHINED ) );

	// This string collects interface discovery information to be displayed
	// once file descriptors have been re-assigned to log files when running
	// in daemon mode.
	std::string ifProbeStr;

	if (interfaceName_ == Mercury::Nub::USE_BWMACHINED)
	{
		// Creating a temporary Nub to query bwmachined for what it
		// knows to be the internalInterface.
		Mercury::Nub nub( 0, Mercury::Nub::USE_BWMACHINED );
		interfaceName_ = inet_ntoa( (struct in_addr &)nub.address().ip );
		ifProbeStr.append( "Discovered network interface '" );
		ifProbeStr.append( interfaceName_.c_str() );
		ifProbeStr.append( "'\n" );
	}

	if (interfaceName_.empty())
	{
		ifProbeStr.append(
			"Logger::init: Assuming monitoringInterface of eth0\n" );
		interfaceName_ = "eth0";
	}

	ifProbeStr.append( "Logger::init: interfaceName = '" );
	ifProbeStr.append( interfaceName_.c_str() );
	ifProbeStr.append( "'\n" );
	watcherNub_.init( interfaceName_.c_str(), 0 );

	u_int16_t localPort = 0;
	u_int32_t localIP = 0;
	this->socket().getlocaladdress( &localPort, &localIP );
	Mercury::Address localAddr( localIP, localPort );

	// watcherNub_.socket().setnonblocking( false );

	// Set maximum receive buffer size for logger
	int recvbuf;
	FILE *file = fopen( "/proc/sys/net/core/rmem_max", "r" );
	fscanf( file, "%d", &recvbuf );
	fclose( file );
	setsockopt( this->socket(), SOL_SOCKET, SO_RCVBUF,
		(const char *)&recvbuf, sizeof( int ) );

	watcherNub_.setRequestHandler( this );

	bool hadPlusOption = false;
	const char *root = NULL, *config = NULL;

	g_shouldWriteToConsole = true;
	g_shouldWriteTimePrefix = true;

	// parse command line.
	for (int i=1; i<argc; ++i)
	{
		std::string arg( argv[i] );

		if (argv[i][0] == '-')
		{
			if (arg == "-h" || arg == "--help" )
			{
				g_shouldWriteToConsole = true;
				dprintf( USAGE_MESSAGE );
				return false;
			}
			else if ((arg == "-q") || (arg == "--quiet"))
			{
				quietMode_ = true;
				g_shouldWriteToConsole = false;
			}
			else if (arg == "-v")
			{
				pLog_->writeToStdout( true );
			}
			else if (arg == "-t" || arg == "--text")
			{
				pLog_->writeTextLogs( true );
			}
			else if (arg == "-p")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -p\n" );
				}
				else
				{
					logNames_.push_back( argv[i] );
				}
			}
			else if (arg == "-d")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -d\n" );
				}
				else
				{
					doNotLogNames_.push_back( argv[i] );
				}
			}
			else if (arg == "-o")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no file specified for -o\n" );
					return false;
				}
				else
				{
					outputFilename_ = argv[i];

					if (outputFilename_.c_str()[0] != '/')
					{
						ERROR_MSG( "output filename isn't an absolute path\n" );
						return false;
					}
				}
			}
			else if (arg == "-e")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no file specified for -e\n" );
					return false;
				}
				else
				{
					errorFilename_ = argv[i];

					if (errorFilename_.c_str()[0] != '/')
					{
						ERROR_MSG( "error output filename isn't an absolute path\n" );
						return false;
					}
				}
			}
			else if (arg == "-l")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -l\n" );
					return false;
				}
				else
				{
					loggerID_ = atoi( argv[i] );
					if (loggerID_ > 255)
					{
						ERROR_MSG( "LoggerID must be in range 0-255\n" );
						return false;
					}
					INFO_MSG( "Logging messages destined only for LoggerID: %d\n",
							loggerID_ );
				}
			}
			else if (arg == "-u")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -u\n" );
					return false;
				}
				else
				{
					arg = argv[i];
					if (arg == "all")
					{
						INFO_MSG( "Logging all users\n" );
						logAllUsers_ = true;
					}
					else
					{
						logUser_ = atoi( arg.c_str() );
						logAllUsers_ = false;
						INFO_MSG( "Logging user id %d\n", logUser_ );
					}
				}
			}
			else if (arg == "-c" || arg == "--config")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line\n" );
					return false;
				}
				else
				{
					config = argv[i];
				}
			}
			else if (arg == "--daemon")
			{
				daemonMode_ = true;
			}
			else
			{
				char buf[ 128 ];
				snprintf( buf, 128, "filter/%s", arg.c_str() + 1 );
				if (!Watcher::rootWatcher().setFromString( NULL, buf, "false" ))
				{
					ERROR_MSG( "Unknown option %s\n", arg.c_str() );
					return false;
				}
			}
		}
		else if (arg[0] == '+')
		{
			if (!hadPlusOption)
			{
				hadPlusOption = true;
				for (int i = 0; i < NUM_MESSAGE_PRIORITY; ++i)
					shouldLogMessagePriority_[ i ] = false;
			}

			char buf[ 128 ];
			snprintf( buf, 128, "filter/%s", arg.c_str() + 1 );
			if (!Watcher::rootWatcher().setFromString( NULL, buf, "true" ))
			{
				ERROR_MSG( "Unknown option %s\n", arg.c_str() );
				return false;
			}
		}
		else
		{
			if (arg[0] != '\0')
				root = argv[i];
		}
	}

	if (root && root[0] != '/')
	{
		ERROR_MSG( "Logger::init: Log directory must be an absolute path\n" );
		return false;
	}

#ifndef _WIN32
	if (daemonMode_)
	{
		daemon( 0, int( g_shouldWriteToConsole ) );
	}
#endif

	this->resetFileDescriptors();

	START_MSG( "message_logger" );

	// Now display all the interface discovery information
	{
		int offset = 0;
		int pos = ifProbeStr.find( '\n', offset );
		while ( pos != -1 )
		{
			INFO_MSG( ifProbeStr.substr( offset, (pos + 1) - offset ).c_str() );

			offset = pos + 1;
			pos = ifProbeStr.find( '\n', offset );
		}
	}


	// Have to init the log after the fork() to get the correct PID.
	if (!pLog_->init( root, "a+", config ))
	{
		ERROR_MSG( "Logger::init: BWLog init failed\n" );
		return false;
	}

	// Must start after daemon call so that we get the correct PID.
	{
		if (watcherNub_.registerWatcher(
				0, MESSAGE_LOGGER_NAME, "MessageLogger" ) != 0)
		{
			ERROR_MSG( "Logger::init: Failed to register watcher\n" );
			return false;
		}
	}

	// Register birth and death listeners.
	{
		ListenerMessage lm;
		lm.port_ = localPort;
		lm.category_ = lm.WATCHER_NUB;
		lm.uid_ = lm.ANY_UID;
		lm.pid_ = mf_getpid();
		lm.name_ = ""; // Match everything.

		// Post data is address salt
		uint16 salt = 0;
		lm.postAddr_ = std::string( (char*)&salt, 2 );

		uint32 msgType;

		// We can't use the logger's main socket to do this registration because
		// of the following:
		// 1. We send the registration message with registerWatcher() above.
		// 2. bwmachined2 receives the registration message and calls
		//    broadcastToListeners() which sends a birth notification to itself.
		// 3. We send the birth listener message.
		// 4. The birth listener message is processed.
		// 5. The birth notification bwmachined sent to itself arrives.
		// 6. The birth notification message is sent back to the logger's main
		//    socket.
		// 7. The death listener sendAndRecv() starts and the notification
		//    message is mistakenly processed as a reply, causing the old error:
		//    ERROR: MGMPacket::read: Not enough bytes on stream (wanted 808)

		// The birth listener.
		lm.param_ = lm.PARAM_IS_MSGTYPE | lm.ADD_BIRTH_LISTENER;
		msgType = MESSAGE_LOGGER_PROCESS_BIRTH;
		lm.preAddr_ = std::string( (char*)&msgType, 4 );
		if (lm.sendAndRecvFromEndpointAddr( this->socket(), LOCALHOST ) !=
			Mercury::REASON_SUCCESS)
		{
			ERROR_MSG( "Logger::init: Failed to register birth listener!\n" );
			return false;
		}

		// The death listener.
		lm.param_ = lm.PARAM_IS_MSGTYPE | lm.ADD_DEATH_LISTENER;
		msgType = MESSAGE_LOGGER_PROCESS_DEATH;
		lm.preAddr_ = std::string( (char*)&msgType, 4 );
		if (lm.sendAndRecvFromEndpointAddr( this->socket(), LOCALHOST ) !=
			Mercury::REASON_SUCCESS)
		{
			ERROR_MSG( "Logger::init: Failed to register death listener!\n" );
			return false;
		}
	}

	const char * addPath = "logger/add";
	const int addPathSize = strlen( addPath ) + 1;
	const char * delPath = "logger/del";
	const int delPathSize = strlen( delPath ) + 1;
	const char * localAddrStr = (char *)localAddr;
	const int addrSize = strlen( localAddrStr ) + 1;

	// This is so damn ugly.  An interface for modifying these things should
	// really be written.
	char buf[ 128 ];
	WatcherDataMsg & wdm = *(WatcherDataMsg *)buf;
	wdm.message = WATCHER_MSG_SET;
	wdm.count = 1;
	memcpy( wdm.string, addPath, addPathSize );
	memcpy( wdm.string + addPathSize, localAddrStr, addrSize );
	addLoggerData_.assign( buf, sizeof(wdm) + addPathSize + addrSize );

	memcpy( wdm.string, delPath, delPathSize );
	memcpy( wdm.string + delPathSize, localAddrStr, addrSize );
	delLoggerData_.assign( buf, sizeof(wdm) + delPathSize + addrSize );

	this->findComponents();

	return true;
}


/**
 *	Destructor.
 */
Logger::~Logger()
{
	// Detach all
	{
		// TODO: We should add a timeout so that components attached to the
		// logger will timeout if they haven't received a ping (addComponent)
		// every so often.
		Components::const_iterator iter = components_.begin();

		while (iter != components_.end())
		{
			Mercury::Address addr = iter->first;
			++iter;

			this->delComponent( addr );
		}
	}

	g_pInstance_ = NULL;
}


/**
 *	This method processes the next network packet.
 */
bool Logger::handleNextMessage()
{
	// If a log rolling is scheduled, do it now
	if (shouldRoll_)
	{
		if (!pLog_->roll())
		{
			ERROR_MSG( "Logger::handleNextMessage: "
				"Failed to roll component logs\n" );
		}

		this->resetFileDescriptors();

		shouldRoll_ = false;
	}

	// Select for up to 500ms so that we occasionally check whether we
	// have finished or we need to roll the logs
	fd_set fds;
	FD_ZERO( &fds );
	FD_SET( this->socket(), &fds );

	timeval tv;
	tv.tv_sec = 0;
	tv.tv_usec = 500000;

	if (select( this->socket() + 1, &fds, NULL, NULL, &tv ))
	{
		watcherNub_.receiveRequest();
		return true;
	}

	return false;
}

/**
 * Shutdown and re-open any files being used to redirect stdout/stderr.
 *
 * @returns true on success, false on error.
 */
bool Logger::resetFileDescriptors()
{
	int defFlags = O_APPEND | O_CREAT | O_WRONLY;
	mode_t defMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
	bool status = true;

	// TODO: should we test the open/append/create before daemon so we can
	//      die with some message to stdout
	if (outputFilename_.length())
	{
		int ofd = open( outputFilename_.c_str(), defFlags , defMode );
		if (ofd == -1)
		{
			ERROR_MSG( "Failed to open '%s' for redirecting stdout: %s\n",
						outputFilename_.c_str(), strerror(errno) );
			status = false;
		}
		else
		{
			MF_ASSERT( ofd != 1 );
			// dup2 will now shutdown stdout and duplicate the output file fd.
			if (-1 == dup2( ofd, 1 ))
			{
				ERROR_MSG( "Failed to dup2 '%s' to stdout. %s.\n",
							outputFilename_.c_str(), strerror(errno) );
				status = false;
			}

			// shutdown the temporary fd now that stdout owns it
			close(ofd);
		}
	}


	if (errorFilename_.length())
	{
		if (errorFilename_ == outputFilename_)
		{
			if (-1 == dup2( 1, 2 ))
			{
				ERROR_MSG( "Failed to dup2 stdout to stderr. %s.\n",
							strerror(errno) );
				status = false;
			}
		}
		else
		{
			int efd = open( errorFilename_.c_str(), defFlags, defMode );
			if (efd == -1)
			{
				ERROR_MSG( "Failed to open '%s' for redirecting stderr: %s\n",
							errorFilename_.c_str(), strerror(errno) );
				status = false;
			}
			else
			{

				MF_ASSERT( efd != 2 );
				// dup2 will now shutdown stderr and duplicate
				// the error file fd.
				if (-1 == dup2( efd, 2 ))
				{
					ERROR_MSG( "Failed to dup2 '%s' to stderr. %s.\n",
								errorFilename_.c_str(), strerror(errno) );
					status = false;
				}

				// shutdown the temporary fd now that stderr owns it
				close(efd);
			}
		}
	}

	// Throw an error message so any syslog monitoring will catch the errors
	if (!status)
		ERROR_MSG( "Logging may no longer work." );

	return status;
}


// -----------------------------------------------------------------------------
// Section: Machine Guard
// -----------------------------------------------------------------------------

bool Logger::FindHandler::onProcessStatsMessage(
	ProcessStatsMessage &psm, uint32 addr )
{
	if (psm.pid_ == 0)
		return true;

	// We don't want to try to log other message loggers ...
	if (psm.name_ == "message_logger")
		return true;

	Mercury::Address address( addr, psm.port_ );
	INFO_MSG( "Logger::findComponents: Found %s at %s. uid = %d\n",
		psm.name_.c_str(), (char*)address, psm.uid_ );
	logger_.sendAdd( address );
	return true;
}

/**
 *	This method finds all components that are currently running on the network.
 */
void Logger::findComponents()
{
	ProcessStatsMessage psm;
	psm.param_ = psm.PARAM_USE_CATEGORY;
	psm.category_ = psm.WATCHER_NUB;

	if (!logAllUsers_)
	{
		psm.param_ |= psm.PARAM_USE_UID;
		psm.uid_ = logUser_;
	}

	// create our socket..
	Endpoint ep;
	ep.socket( SOCK_DGRAM );
	u_int32_t ifaddr = INADDR_ANY;
	char iftemp[ IFNAMSIZ ];
	ep.findIndicatedInterface( interfaceName_.c_str(), iftemp );
	ep.getInterfaceAddress( iftemp, ifaddr );
	if (!ep.good() || ep.bind( 0, ifaddr ) != 0)
	{
		ERROR_MSG( "Logger::findComponents: Problem setting up socket.\n" );
		return;
	}

	// Do broadcast and read back replies
	FindHandler handler( *this );
	int reason;
	if ((reason = psm.sendAndRecv( ep, BROADCAST, &handler )) !=
		Mercury::REASON_SUCCESS)
	{
		ERROR_MSG( "Logger::findComponents: MGM::sendAndRecv() failed: %s\n",
			Mercury::reasonToString( (Mercury::Reason&)reason ) );
	}
}


// -----------------------------------------------------------------------------
// Section: Message handlers
// -----------------------------------------------------------------------------

/**
 *	This method overrides the WatcherRequestHandler method to handle extension
 *	messages.
 */
void Logger::processExtensionMessage( int messageID,
			char * data, int dataLen, const Mercury::Address & addr )
{
	switch (messageID)
	{
		case MESSAGE_LOGGER_MSG:
		{
			MemoryIStream is( data, dataLen );
			this->handleLogMessage( is, addr );

			// Prevent lots of output about memory stream still containing data
			is.finish();

			break;
		}

		case MESSAGE_LOGGER_REGISTER:
		{
			this->handleRegisterRequest( data, dataLen, addr );
			break;
		}

		case MESSAGE_LOGGER_PROCESS_BIRTH:
		{
			if (dataLen == sizeof( Mercury::Address ))
			{
				Mercury::Address addr = *(Mercury::Address *)data;
				this->handleBirth( addr );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
						"Bad birth size %d\n", dataLen );
			}
			break;
		}

		case MESSAGE_LOGGER_PROCESS_DEATH:
		{
			if (dataLen == sizeof( Mercury::Address ))
			{
				Mercury::Address deadAddr = *(Mercury::Address *)data;

				// If someone sends INADDR_ANY as the address, just use the
				// source address instead
				if (deadAddr.ip == 0)
				{
					deadAddr.ip = addr.ip;
				}

				this->handleDeath( deadAddr );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
						"Bad death size %d\n", dataLen );
			}
			break;
		}

		case MESSAGE_LOGGER_APP_ID:
		{
			if (dataLen == sizeof( int ))
			{
				pLog_->setAppID( addr, *(int*)data );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
					"Bad app ID size %d\n", dataLen );
			}
			break;
		}

		case WATCHER_MSG_TELL:
			// TODO: We may look at these to know whether adds have worked.
			// Ignore tell messages.
			break;

		default:
		{
			for (int i = 0; i < dataLen; ++i)
			{
				char c = data[ i ];
				if ((('a' <= c) && (c <= 'z')) ||
						(('A' <= c) && (c <= 'Z')))
				{
					DEBUG_MSG( "%c\n", c );
				}
				else
				{
					DEBUG_MSG( "0x%02d\n", uint8( c ) );
				}
			}

			StandardWatcherRequestHandler::processExtensionMessage(
					messageID, data, dataLen, addr );
			break;
		}
	}
}

/**
 *	This method is called when a process starts that we may want to watch.
 */
void Logger::handleBirth( const Mercury::Address & addr )
{
}


/**
 *	This method is called when a process stops that we may have been watching.
 */
void Logger::handleDeath( const Mercury::Address & addr )
{
	INFO_MSG( "Logger::handleDeath: %s\n", (char *)addr );
	this->delComponent( addr, /* send: */ false );
}


/**
 *	This method handles a log message from a component.
 */
void Logger::handleLogMessage( MemoryIStream &is, const Mercury::Address &addr )
{
	Components::const_iterator iter = components_.find( addr );

	if (iter == components_.end())
	{
		WARNING_MSG( "Logger::handleLogMessage: "
				"Got message from unregistered component %s\n",
			(char *)addr );

		// TODO: We should probably send an add here, not a del.  The problem at
		// the moment is that server components compiled with out-of-date logger
		// protocol support (see logger_message_forwarder.hpp) will repeatedly
		// generate this warning if we do a naive add here.  We could maybe
		// cache a map of out-of-date components in handleRegisterRequest()
		// below and only send adds to up-to-date components.
		this->sendDel( addr );
		return;
	}

	if (!pLog_->addEntry( iter->second, addr, is ))
	{
		ERROR_MSG( "Logger::handleLogMessage: "
			"BWLog::addEntry() failed, a log entry has been lost!\n" );
	}
}

/**
 *	This method handles a request to register a component.
 */
void Logger::handleRegisterRequest(
			char * data, int dataLen, const Mercury::Address & addr )
{
	MemoryIStream is( data, dataLen );
	Component component;
	component.read( is );

	if (is.error() || is.remainingLength() > 0)
	{
		ERROR_MSG( "Malformed register request from %s\n", (char*)addr );
		return;
	}

	if (this->shouldConnect( component ))
	{
		INFO_MSG( "Registering %s at %s (uid:%d)\n",
			component.name(), (char *)addr, component.uid_ );
		components_[ addr ] = component;
	}
	else
	{
		WARNING_MSG( "Not registering %s at %s\n", component.name(),
			(char*)addr );
		this->sendDel( addr );
	}
}


/**
 *	This method returns whether or not we should accept the input component.
 */
bool Logger::shouldConnect( const Component & component ) const
{
	// make sure client is sending out packets that we know
	// what to do with.
	if (component.version_ != MESSAGE_LOGGER_VERSION)
	{
		if (component.version_ < MESSAGE_LOGGER_VERSION)
		{
			WARNING_MSG( "Not registering %s (uid:%d) (old protocol %d < %d)\n",
				component.componentName_.c_str(), component.uid_,
				component.version_, MESSAGE_LOGGER_VERSION );
		}
		else
		{
			WARNING_MSG( "Process using newer message format asking "
				"to be logged.. update your logger! %d > %d\n",
			   component.version_, MESSAGE_LOGGER_VERSION );
		}
	}
	else if (!logAllUsers_ && (logUser_ != component.uid_))
	{
		// Not our UID.
		// shouldLog = false;
	}
	else if ((loggerID_ != 0) && (loggerID_ != component.loggerID_))
	{
		// Not correct logger id.
	}
	else if (!logNames_.empty() &&
			std::find( logNames_.begin(), logNames_.end(),
							component.componentName_ ) == logNames_.end() )
	{
		// Not in valid names.
	}
	else if (std::find( doNotLogNames_.begin(), doNotLogNames_.end(),
							component.componentName_ ) != doNotLogNames_.end() )
	{
		// Is an invalid name.
	}
	else
	{
		return true;
	}

	return false;
}


// -----------------------------------------------------------------------------
// Section: Misc
// -----------------------------------------------------------------------------

/**
 *	This method sends an add logger request to the input address.
 */
void Logger::sendAdd( const Mercury::Address & addr )
{
	this->socket().sendto(
			(char *)addLoggerData_.data(), addLoggerData_.size(),
			addr.port, addr.ip );
}


/**
 *	This method sends a del logger request to the input address.
 */
void Logger::sendDel( const Mercury::Address & addr )
{
	this->socket().sendto(
			(char *)delLoggerData_.data(), delLoggerData_.size(),
			addr.port, addr.ip );
}


/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent( const Mercury::Address & addr, bool send )
{
	INFO_MSG( "Logger::delComponent: %s\n", (char *)addr );
	components_.erase( addr );

	if (!pLog_->delComponent( addr ))
	{
		ERROR_MSG( "Logger::delComponent: "
			"Failed to stop writing component at %s to the logs\n",
			(char*)addr );
	}

	if (send)
	{
		this->sendDel( addr );
	}
}


/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent( Logger::Component * pComponent )
{
	// This is a bit of a brute-force way of doing things (which is probably
	// fine). We could store the address with the component or we could work
	// it out from pComponent since it comes from a map.

	Components::iterator iter = components_.begin();

	while (iter != components_.end())
	{
		if (pComponent == &iter->second)
		{
			this->delComponent( iter->first );
			return;
		}

		++iter;
	}
}


/**
 *	This method refreshes the components that this logger is connected to.
 */
void Logger::commandReattachAll( bool value )
{
	if (value)
	{
		this->findComponents();
	}
}

// -----------------------------------------------------------------------------
// Section: Logger::Component
// -----------------------------------------------------------------------------


/**
 *	This static method returns a watcher for this type.
 */
Watcher & Logger::Component::watcher()
{
	static DirectoryWatcherPtr pWatcher = NULL;

	if (pWatcher == NULL)
	{
		pWatcher = new DirectoryWatcher();
		Component * pNull = NULL;

		pWatcher->addChild( "name",
 			new MemberWatcher< const char *, Logger::Component >( *pNull,
				&Logger::Component::name ) );
		pWatcher->addChild( "uid", new DataWatcher< uint16 >( pNull->uid_ ) );
		pWatcher->addChild( "pid", new DataWatcher< uint32 >( pNull->pid_ ) );
		pWatcher->addChild( "attached",
			new MemberWatcher< bool, Logger::Component >( *pNull,
				MF_ACCESSORS( bool, Logger::Component, commandAttached ) ) );
	}

	return *pWatcher;
}


/**
 *	This method sents whether or not this component is attached.
 */
void Logger::Component::commandAttached( bool value )
{
	if (!value && g_pInstance_)
	{
		g_pInstance_->delComponent( this );
	}
}
