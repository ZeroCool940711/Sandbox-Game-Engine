<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;3.&nbsp;Trading</title>
      <link rel="stylesheet" href="../css/bigworld.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
      <link rel="start" href="index.html" title="How To Implement Items And Trading">
      <link rel="up" href="index.html" title="How To Implement Items And Trading">
      <link rel="prev" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Items"><script type="text/javascript" src="../css/bigworld.js"></script></head>
   <body onLoad="loader();">
      <div id="bigworld-header"><img src="bigworld_logo.gif" id="bwLogo" alt="bw logo"></div>
      <div id="content">
         <div class="navheader">
            <table width="95%" align="center" summary="Navigation header">
               <tr>
                  <th colspan="3" align="center">Chapter&nbsp;3.&nbsp;Trading</th>
               </tr>
               <tr>
                  <td width="20%" align="left"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;
                  </td>
                  <th width="55%" align="center">&nbsp;</th>
                  <td width="20%" align="right">&nbsp;</td>
               </tr>
            </table>
            <hr class="navheaderline">
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="xref_Trading"></a>Chapter&nbsp;3.&nbsp;Trading
                     </h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <p><b>Table of Contents</b></p>
               <dl>
                  <dt><span class="sect1"><a href="ch03.html#d0e852">3.1. Trade Protocol</a></span></dt>
                  <dt><span class="sect1"><a href="ch03.html#xref_Trading_Supervisor">3.2. Trading Supervisor</a></span></dt>
                  <dt><span class="sect1"><a href="ch03.html#xref_Dealing_With_Failure_Conditions">3.3. Dealing with failure conditions</a></span></dt>
                  <dt><span class="sect1"><a href="ch03.html#xref_Creating_And_Destroying_The_Trading_Supervisor">3.4. Creating and destroying the trading supervisor</a></span></dt>
                  <dt><span class="sect1"><a href="ch03.html#d0e1358">3.5. Scalability</a></span></dt>
                  <dt><span class="sect1"><a href="ch03.html#d0e1385">3.6. Vulnerabilities</a></span></dt>
               </dl>
            </div>
            <p>This chapter describes one of the possible ways in which players can
                   buy, sell, or exchange goods between themselves or with
                   <em class="emphasis">NPC</em>'s.
            </p>
            <p>The process is basically the same in both situations. One player
                   will initiate the trade, then a user interface will appear, which can be
                   similar to the <em class="emphasis">Inventory</em> one, but showing the
                   inventory (or partial inventory) of both parties. The two parties can then
                   choose which items to buy, sell, or exchange, and once they both agree on
                   the trade, the changes can be updated on the server.
            </p>
            <p>Strict transaction control is recommended for trading so that there
                   is little chance for exploitation, cheating, or item loss. Care should
                   also be taken when creating temporary items, since this may lead to the
                   duplication of items. For similar reasons, this control should be done on
                   the server, to ensure that one client does not try to exploit another.
                   Again, the authoritative copy of any inventory should live on the server,
                   so that clients can re-read the information from it if they do not agree
                   on the trade.
            </p>
            <p>There are many levels of protection that can be obtained in a
                   trading system, with each higher level involving more control
                   overhead.
            </p>
            <p>A trading system needs protection against hardware and software
                   failures in order to ensure <em class="emphasis">transaction
                      atomicity</em><em class="emphasis">, <em class="emphasis">making sure that an item is
                         neither lost nor duplicated</em></em>. It means that a
                   transaction in progress does not stop half way if a component in the
                   system fails.
            </p>
            <p>The possible approaches to <em class="emphasis">item trade</em> are
                   listed below, in order of increased cost:
            </p>
            <p>Simply swap the items, without performing database
                   <em class="emphasis">writes</em>. This approach relies on built-in fault
                   tolerance and disaster recovery, and therefore might have a reasonably
                   large window for item loss or duplication.
            </p>
            <div class="itemizedlist">
               <ul type="disc">
                  <li>
                     <p>Swap the items and immediately write to the database (two
                                database <em class="emphasis">writes</em> per trade). This approach reduces
                                the window for item loss and duplication.
                     </p>
                  </li>
                  <li>
                     <p>Use a <em class="emphasis">trading supervisor</em> (three database
                                <em class="emphasis">writes</em> per trade), leveraging BigWorld's fault
                                tolerance capabilities. This approach results in a high overhead per
                                item.
                     </p>
                  </li>
                  <li>
                     <p>Make each item an <em class="emphasis">entity</em>.
                     </p>
                  </li>
                  <li>
                     <p>Implement external banking-grade database transaction.</p>
                  </li>
               </ul>
            </div>
            <p>Like all forms of insurance, the game implementer must weigh up the
                   importance of losing or duplicating items against the cost of such
                   protection.
            </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e852"></a>3.1.&nbsp;Trade Protocol
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Before a trade transaction can take place, both parties must agree
                        on the items being traded. If one of the parties is a NPC character,
                        price tables can be used and this is not an issue. If both parties are
                        players, care must be taken so that players cannot cheat one
                        another.
               </p>
               <p>Player misinterpretation can occur if players are not given the
                        chance to inspect the items offered by their trade partner, or if the
                        player can initiate the transaction after changing his offer once the
                        other has already accepted the trade.
               </p>
               <p>To avoid player misinterpretation problems, the sample
                        implementation uses a trade protocol that allows players to offer,
                        switch, inspect, accept, and refuse items at will until a consensus is
                        reached and the trade can be processed. The protocol is described
                        bellow.
               </p>
               <div class="orderedlist">
                  <ol type="1">
                     <li>
                        <p>The player offers an item. The item is locked locally and the
                                     offer is sent to the cell.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In </em><em class="emphasis"><span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/Avatar.py</span>:</em></p><pre class="programlisting">def onTradeOfferItem( self, itemSerial ):
    ...
    self._tradeOfferLock = self.inventoryMgr.itemsLock( [itemSerial], 0 )
    self.cell.tradeOfferItemRequest( self._tradeOfferLock, itemSerial )
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The cell tries to confirm the lock with the base.</p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis"><span class="literal">In
                                                        <em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/Avatar.py:</span></em></p><pre class="programlisting">def tradeOfferItemRequest( self, sourceID, lockHandle, itemSerial ):
    ...
    self.tradeOutboundLock = lockHandle
    self.base.itemsLockRequest( lockHandle, [itemSerial], goldPieces )</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The base repeats the lock done on the client and notifies the
                                     cell of the result.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/Avatar.py</span>:</em></p><pre class="programlisting">def itemsLockRequest( self, lockHandle, itemsSerials, goldPieces ):
    ...
    inventoryMgr = self.inventoryMgr
    ...
    inventoryMgr.itemsRelock( lockHandle, itemsSerials, goldPieces )
    ...
    self.cell.itemsLockNotify( True, lockHandle,
            itemsSerials, itemsTypes, goldPieces )
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p><a name="xref_Trade_Protocol_Step_4"></a>If the locking on the base was successful, the cell notifies
                                     the partner about the offer.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/Avatar.py</span>:</em></p><pre class="programlisting">def itemsLockNotify( self, success, lockHandle ... ):
    ...
    partner = self._getModeTarget()
    ...
    partner.tradeOfferItem( itemsTypes[0] )
    ...

def tradeOfferItem( self, itemType ):
    self.tradeSelfAccepted = False
    self.client.tradeOfferItemNotify( itemType )</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The player is notified about the offer made by his trade
                                     partner. The item is shown on the user interface.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal">/<em class="replaceable"><code>&lt;res&gt;</code></em>scripts/client/Avatar.py</span>:</em></p><pre class="programlisting">def tradeOfferItemNotify( self, itemType ):
    ...
    self.inventoryGUI.showOfferedItem( itemType )
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The player accepts the item offered. The client notifies the
                                     cell about the approval.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/Avatar.py</span>:</em></p><pre class="programlisting">def onTradeAccept( self, accept ):
    ...
    self.cell.tradeAcceptRequest( accept )</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The cell notifies the trade partner about the approval. The
                                     notification is immediately forwarded to the client.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/Avatar.py</span>:</em></p><pre class="programlisting">def tradeAcceptRequest( self, sourceID, accepted ):
    ...
    self.tradeSelfAccepted = accepted
    partner = self._getModeTarget()
    partner.tradeAcceptNotify( accepted )
    ...

def tradeAcceptNotify( self, accepted ):
    ...
    self.client.tradeAcceptNotify( accepted )
    self.tradePartnerAccepted = accepted
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The player is notified about the approval by his trade
                                     partner. The user interface is updated to reflect that.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/Avatar.py</span>:</em></p><pre class="programlisting">def tradeAcceptNotify( self, accepted ):
    self.inventoryGUI.tradeOfferAccept( accepted )</pre></li>
                           </ul>
                        </div>
                     </li>
                  </ol>
               </div>
               <p>Note that whenever the player&#8217;s partner offers a new item, its
                        accepted flag is set to <span class="literal">False</span> (<a href="ch03.html#xref_Trade_Protocol_Step_4">step 4</a>). This ensures that a
                        trade will never be processed without the explicit approval, from both
                        parties, for the most current item offered.
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="xref_Trading_Supervisor"></a>3.2.&nbsp;Trading Supervisor
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Once both parties have agreed on the items to be traded, the
                        trading can take place. The sample implementation makes use of a
                        <em class="emphasis">trading supervisor</em> to coordinate and direct the
                        trade.
               </p>
               <p>In summary, the trading supervisor works as follows: each
                        participant in a trade has a <em class="emphasis">trade id</em>, which
                        increases monotonically. Before starting a new trade, the supervisor
                        writes and entry for the pending trade into the database. The supervisor
                        then requests the participants to perform the transaction. After
                        completion of the transaction, each participant notifies the supervisor
                        about the trade completed. The entry for pending trade is removed from
                        the database. If the system starts up after a failure, the supervisor
                        lists all pending trades from the database and replays them. The
                        participants use their <em class="emphasis">trade id</em>s to determine
                        whether they have carried out the trade. If they have not, the
                        transaction is performed. If they did have, the redundant request is
                        simply ignored.
               </p>
               <div class="orderedlist">
                  <ol type="1">
                     <li>
                        <p>When both avatar have agreed on items, the active cell
                                     instructs the base to initiate the transaction
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/Avatar.py</span>:</em></p><pre class="programlisting">def tradeAcceptRequest( self, sourceID, accepted ):
    ...
    self._tryTradeBegin()

def _tryTradeBegin( self ):
    if self.mode == Mode.TRADE_ACTIVE and \
        self.tradePartnerAccepted and \
            self.tradeSelfAccepted:
        ...
        self.base.tradeCommitActive( self.tradeOutboundLock )
        partner = self._getModeTarget()
        partner.tradeCommitPassive( self.base )</pre></li>
                           </ul>
                        </div>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                           <h3 class="title">Note</h3>
                           <p>The sample implementation uses the concept active/passive
                                          roles in the trade.
                           </p>
                           <p>The <em class="emphasis">active</em> participant will be the one
                                          requesting the trade to the trading supervisor. In the sample, the
                                          roles are chosen based on who started the trading mode.
                           </p>
                           <p>You can use whatever criteria you think is best suited to
                                          your design (<em class="emphasis">e.g.</em>, higher entity ID).
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>In the base, the avatar in the active participant informs the
                                     trading supervisor of the trade ids and the data about items and
                                     gold pieces being traded. The data about the trade includes
                                     information about each avatar&#8217;s giveaway: serial number and type ids
                                     of items and amount of gold pieces.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis"> In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/Avatar.py</span>:</em></p><pre class="programlisting">...
def tradeSyncRequest( self, partnerBase, partnerTradeParams ):
    ...
    ourItemsTypes, ourGoldPieces = \
        inventoryMgr.itemsLockedRetrieve( self.outItemsLock )

    supervisor = BigWorld.globalBases[ "TradingSupervisor" ]

    selfTradeParams = { "dbID" : self.databaseID, \
                        "tradeID" : self.lastTradeID + 1, \
                        "lockHandle": self.outItemsLock, \
                        "itemsSerials": outItemsSerials, \
                        "itemsTypes": outItemsTypes, \
                        "goldPieces": outGoldPieces }

    if supervisor.commenceTrade( self, selfTradeParams,
            partnerBase, partnerTradeParams ):
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p><a name="xref_Trading_Supervisor_Step_3"></a>The <em class="emphasis">trading supervisor</em> adds the trading
                                     data to its list of pending trades and writes itself to the
                                     database.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">...
def commenceTrade( self, A, paramsA, B, paramsB ):
    ...
    tradeLog = { "typeA": A.__class__.__name__, "paramsA": paramsA,
                 "typeB": B.__class__.__name__, "paramsB": paramsB }

    self.recentTrades.append( tradeLog )
    self.outstandingTrades.append( [A.id, B.id] )

    def doTradeStep2( *args ):
        self._tradeStep2( A, paramsA, B, paramsB )

    self.writeToDB( doTradeStep2 )
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p><a name="xref_Trading_Supervisor_Step_4"></a>Once the <em class="emphasis">trading supervisor</em> is notified
                                     by the database that <em class="emphasis">write</em> is complete, it
                                     instructs both avatars to modify their inventories, in order to
                                     reflect the result of the trade.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">...
def _tradeStep2( self, A, paramsA, B, paramsB ):

    A.tradeCommit( 
        self, paramsA[ "tradeID" ], paramsA[ "lockHandle" ],
        paramsA[ "itemsSerials" ], paramsA[ "goldPieces" ],
        paramsB[ "itemsTypes" ], paramsB[ "goldPieces" ] )
    B.tradeCommit( 
        self, paramsB[ "tradeID" ], paramsB[ "lockHandle" ],
        paramsB[ "itemsSerials" ], paramsB[ "goldPieces" ],
        paramsA[ "itemsTypes" ], paramsA[ "goldPieces" ] )</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The avatars modify their inventories, increment their
                                     <em class="emphasis">trade id</em>'s, and write themselves to the
                                     database.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/Avatar.py</span>:</em></p><pre class="programlisting">...
def tradeCommit( 
        self, supervisor, tradeID, 
        outItemsLock, outItemsSerials, inItemsTypes, inGoldPieces ):
    TradeHelper.tradeCommit( 
        self, supervisor, tradeID, outItemsLock,
        outItemsSerials, outGoldPieces,
        inItemsTypes, inGoldPieces )</pre></li>
                           </ul>
                        </div>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradeHelper.py</span>:</em></p><pre class="programlisting">...
def tradeCommit( 
        self, supervisor, tradeID, 
        outItemsLock, outItemsSerials, inItemsTypes, inGoldPieces ):
    ...
    inItemsSerials = base.inventoryMgr.itemsTrade(
            outItemsSerials, outGoldPieces, inItemsTypes,
            [], inGoldPieces, outItemsLock )
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>Once each avatar is notified by the database that its
                                     <em class="emphasis">write</em> is complete, it informs the
                                     <em class="emphasis">trading supervisor</em>.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradeHelper.py</span>:</em></p><pre class="programlisting">...
def tradeCommit( ... ):
    ...
    base.writeToDB( lambda *args: completeTrade( inItemsSerials ) )</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p><a name="xref_Trading_Supervisor_Step_7"></a>Once the <em class="emphasis">trading supervisor</em> is informed
                                     by both parties that their <em class="emphasis">writes</em> are complete,
                                     it removes the trade from its list of pending trades.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">...
def completeTrade( self, who, tradeID ):
    nost = []
    for t in self.outstandingTrades:
        if t[0] == who.id:
            if t[1] == 0:
                self.recentTrades.pop(len(nost))
                print "TradingSupervisor: trade complete by A"
            else:
                nost.append( (0,t[1]) )
        elif t[1] == who.id:
            if t[0] == 0:
                self.recentTrades.pop(len(nost))
                print "TradingSupervisor: trade complete by B"
            else:
                nost.append( (t[0],0) )
        else:
            nost.append( t )
    self.outstandingTrades = nost
</pre></li>
                           </ul>
                        </div>
                     </li>
                  </ol>
               </div>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>After the <span class="literal">write</span> of a pending trade has been
                             committed into the database (<a href="ch03.html#xref_Trading_Supervisor_Step_3">step 3</a>), the trade is
                             guaranteed to be completely carried out on both participant Avatars
                             (<a href="ch03.html#xref_Trading_Supervisor_Step_4">step 4</a> to <a href="ch03.html#xref_Trading_Supervisor_Step_7">step 7</a>), even if the
                             system fails at any time during the execution of the
                             transaction.
                  </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="xref_Dealing_With_Failure_Conditions"></a>3.3.&nbsp;Dealing with failure conditions
                        </h2>
                     </div>
                  </div>
               </div>
               <p>The system has been designed to cope with component failure. The
                        sample implementation follows the steps below:
               </p>
               <div class="orderedlist">
                  <ol type="1">
                     <li>
                        <p>Upon start up, the <em class="emphasis">trading supervisor</em>
                                     consult its list of pending trades:
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span></span>:</em></p><pre class="programlisting">def __init__( self ):
    ...
    if self.recentTrades == []:
        ...
    else:
        ...
        for trade in self.recentTrades:
            self._replayTrade( trade ) 
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>The <em class="emphasis">supervisor</em> extracts from the database
                                     the avatars involved in the trades (in case they have not already
                                     been extracted):
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">def __init__( self ):
    ...
    for trade in self.recentTrades:
        self._replayTrade( trade )

def _replayTrade( self, trade ):
    traderMBs = [None, None]
    BigWorld.createBaseFromDBID( trade[ "typeA" ], 
        trade[ "paramsA" ][ "dbID" ],
        lambda mb, dbID, wasActive: self.__collectMailbox ( trade[ "typeA" ], 
            trade, traderMBs, 0, mb ) )
    BigWorld.createBaseFromDBID( trade[ "typeB" ], 
        trade[ "paramsB" ][ "dbID" ],
        lambda mb, dbID, wasActive: self.__collectMailbox ( trade[ "typeB" ], 
            trade, traderMBs, 1, mb ) )

def __collectMailbox ( self, entityType, trade, traderMBs, ind, box ):
    ...
    traderMBs[ ind ] = box
    if traderMBs[ ind^1 ] == None: 
        return # still missing other mailbox

    self._tradeStep2( traderMBs[0], trade[ "paramsA" ], 
                      traderMBs[1], trade[ "paramsB" ] )</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>It then replays the trades, by instructing the avatars to
                                     perform it (see <a href="ch03.html#xref_Trading_Supervisor_Step_4">step
                                        4</a> to <a href="ch03.html#xref_Trading_Supervisor_Step_7">step
                                        7</a> in <a href="ch03.html#xref_Trading_Supervisor" title="3.2.&nbsp;Trading Supervisor">Trading Supervisor</a>).
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>Overall, the procedure is similar to a journal file system,
                             <em class="emphasis">i.e.</em>, the intentions are first written to the
                             database, then the operation is performed, and finally the intentions
                             are marked as complete.
                  </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="xref_Creating_And_Destroying_The_Trading_Supervisor"></a>3.4.&nbsp;Creating and destroying the trading supervisor
                        </h2>
                     </div>
                  </div>
               </div>
               <p>In the case of a global trading supervisor, the supervisor must be
                        created when the system is first started. In the sample implementation,
                        that is done in the base personality script
                        (<span class="literal">FantasyDemo.py</span>).
               </p>
               <p>Whenever a new base is started, a three-step procedure is
                        performed to bring up the global
                        <span class="literal">TradingSupervisor</span>.
               </p>
               <div class="orderedlist">
                  <ol type="1">
                     <li>
                        <p><a name="xref_Creating_And_Destroying_The_Trading_Supervisor_Step_1"></a>Check if a global supervisor has not already been
                                     created.
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/FantasyDemo.py</span>:</em></p><pre class="programlisting">import BigWorld
...
def onBaseAppReady( isBootstrap ):
    ...
    TradingSupervisor.wakeupTradingSupervisor()
    ...</pre></li>
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">def wakeupTradingSupervisor():
    ...
    if BigWorld.globalBases.has_key( 'TradingSupervisor' ):
        ...
    self:
        doStep2()
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p><a name="xref_Creating_And_Destroying_The_Trading_Supervisor_Step_2"></a>If not, try to load one from the database (if one is found
                                     there, the system has failed, and there can be some trades pending.
                                     For more details on replaying trades, see <a href="ch03.html#xref_Dealing_With_Failure_Conditions" title="3.3.&nbsp;Dealing with failure conditions">Dealing with failure conditions</a>).
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In </em><em class="emphasis"><span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">def wakeupTradingSupervisor():
    ....
    def doStep2():
        BigWorld.createBaseFromDB( 'TradingSupervisor', 
                'TradingSupervisor', doStep3 )
    ...</pre></li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>If none was found in the database, create a new supervisor
                                     (the system is coming up after a clean shutdown).
                        </p>
                        <div class="itemizedlist">
                           <ul type="disc">
                              <li>
                                 <p><em class="emphasis">In </em><em class="emphasis"><span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">def wakeupTradingSupervisor():
    ....
    def doStep3( result ):
        if result:
            ...
        else:
            BigWorld.createEntity( 'TradingSupervisor' )
    ...</pre><p>The fact that this three-step sequence is performed on
                                                  every base that comes up allow two or more bases that are
                                                  starting up simultaneously to create one supervisor each (if all
                                                  get <span class="literal">False</span> from their query for the global
                                                  base in <a href="ch03.html#xref_Creating_And_Destroying_The_Trading_Supervisor" title="3.4.&nbsp;Creating and destroying the trading supervisor">step
                                                     1</a>). In case two or more supervisors are created, only one
                                                  of them will be able to register itself globally. The ones that
                                                  do not will destroy themselves immediately.
                                 </p>
                              </li>
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">class TradingSupervisor:
    ....
    def __init__( self ):
        ...
        def registerGloballyResult( success ):
            if not success:
                self.destroy()

        self.registerGlobally( self.globalName, registerGloballyResult )</pre><p>In <a href="ch03.html#xref_Creating_And_Destroying_The_Trading_Supervisor_Step_2">step
                                                     2</a> in the supervisor startup procedure, the system is
                                                  assumed to have come from a clear shutdown if the trading
                                                  supervisor cannot be retrieved from the database. One way to
                                                  make sure this is always the case is deleting the trading
                                                  supervisor from the database whenever the system is
                                                  shutdown.
                                 </p>
                              </li>
                              <li>
                                 <p><em class="emphasis">In </em><em class="emphasis"><code class="filename"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/FantasyDemo.py</code>:</em></p><pre class="programlisting">def destroyTradingSupervisor():
    ....
    dbid = supervisor.databaseID
    supervisor.destroy()
    ...</pre></li>
                              <li>
                                 <p><em class="emphasis">In
                                                     <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/TradingSupervisor.py</span>:</em></p><pre class="programlisting">def destroyTradingSupervisor():
    ....
    dbid = supervisor.databaseID
    supervisor.destroy()</pre></li>
                           </ul>
                        </div>
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e1358"></a>3.5.&nbsp;Scalability
                        </h2>
                     </div>
                  </div>
               </div>
               <p>The example uses only one system-wide <em class="emphasis">trading
                           supervisor</em>. However, it is easily scalable to as many as
                        necessary.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>Care should be taken as to not create multiple <em class="emphasis">trading
                                supervisors</em> on a single <span class="literal">BaseApp</span> when
                             restoring them in a controlled startup.
                  </p>
               </div>
               <p>A simple way to do this would be to create one trading supervisor
                        instance per BaseApp, and access it through a Python global variable on
                        that <span class="literal">BaseApp</span>. This could be done in the
                        <span class="literal">onBaseAppReady</span> callback of the personality script or
                        via an accessor that creates it on first access.
               </p>
               <p>There are also alternatives to how this idea is implemented. For
                        example, the pending trade could be stored with one of the traders. This
                        reduces the number of writes to the database and avoids scalability
                        issues. An extra field would be required per Avatar.
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e1385"></a>3.6.&nbsp;Vulnerabilities
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Despite the high level of protection against crashes afforded by
                        this example solution, there are still conditions in which the trade can
                        go awry.
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p><em class="emphasis">Database corruption</em></p>
                        <p>If the database corrupts itself, then the list of pending
                                     transactions might not be available. Most databases have good
                                     protection against this.
                        </p>
                     </li>
                     <li>
                        <p><em class="emphasis">Scripting errors</em></p>
                        <p>Care must also be taken to ensure that the inventory is not
                                     modified in other unexpected ways. This may include ensuring any
                                     items in a trade are not lost before it is complete. For details,
                                     see <a href="ch02.html#xref_Locking_Inventory_Items" title="2.6.&nbsp;Locking inventory items">Locking inventory items</a>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="navfooter">
            <hr class="navheaderline">
            <table width="95%" align="center" summary="Navigation footer">
               <tr>
                  <td width="38%" align="left"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;
                  </td>
                  <td width="20%" align="center">&nbsp;</td>
                  <td width="37%" align="right">&nbsp;</td>
               </tr>
               <tr>
                  <td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Items&nbsp;</td>
                  <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
                  <td width="40%" align="right" valign="top">&nbsp;</td>
               </tr>
               <tr>
                  <td colspan="3">Copyright 1999-2008 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.
                     		   
                  </td>
               </tr>
            </table>
         </div>
      </div>
   </body>
</html>