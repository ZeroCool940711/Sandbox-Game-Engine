<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;3.&nbsp;How to Move Server-Controlled Entities</title>
      <link rel="stylesheet" type="text/css" href="../css/bigworld.css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="How To Move Entities">
      <link rel="up" href="index.html" title="How To Move Entities">
      <link rel="prev" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Navigation Mesh">
      <link rel="next" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Filters">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div id="bigworld-header"><img src="http://try.bigworldtech.com/bigworld/image.php?img=bigworld_logo.gif&amp;svn=$HeadURL: http://patchsvn/svn/evaluation/official/IndiePackage/2.1/current/bigworld/doc/html/howto_move_entities/ch03.html $" alt="bw logo"></div>
      <div id="content">
         <div class="navheader">
            <table width="95%" align="center" summary="Navigation header">
               <tr>
                  <th colspan="3" align="center">Chapter&nbsp;3.&nbsp;How to Move Server-Controlled Entities</th>
               </tr>
               <tr>
                  <td width="20%" align="left"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;
                  </td>
                  <th width="55%" align="center">&nbsp;</th>
                  <td width="20%" align="right">&nbsp;<a accesskey="n" href="ch04.html">Next</a></td>
               </tr>
            </table>
            <hr class="navheaderline">
         </div>
         <div class="chapter" title="Chapter&nbsp;3.&nbsp;How to Move Server-Controlled Entities">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="xref_How_To_Move_Server_Controlled_Entities"></a>Chapter&nbsp;3.&nbsp;How to Move Server-Controlled Entities
                     </h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <p><b>Table of Contents</b></p>
               <dl>
                  <dt><span class="section"><a href="ch03.html#d0e118">3.1. <span class="literal">moveToPoint</span></a></span></dt>
                  <dt><span class="section"><a href="ch03.html#d0e146">3.2. Navigation</a></span></dt>
                  <dd>
                     <dl>
                        <dt><span class="section"><a href="ch03.html#d0e155">3.2.1. <span class="literal">canNavigateTo()</span></a></span></dt>
                        <dt><span class="section"><a href="ch03.html#d0e173">3.2.2. <span class="literal">navigateStep()</span></a></span></dt>
                        <dt><span class="section"><a href="ch03.html#d0e199">3.2.3. <span class="literal">navigateFollow()</span></a></span></dt>
                        <dt><span class="section"><a href="ch03.html#d0e208">3.2.4. <span class="literal">navigate()</span></a></span></dt>
                     </dl>
                  </dd>
                  <dt><span class="section"><a href="ch03.html#d0e217">3.3. Example navigating cell entity</a></span></dt>
                  <dd>
                     <dl>
                        <dt><span class="section"><a href="ch03.html#d0e222">3.3.1. Loading</a></span></dt>
                        <dt><span class="section"><a href="ch03.html#d0e242">3.3.2. Moving</a></span></dt>
                        <dt><span class="section"><a href="ch03.html#d0e264">3.3.3. Client-side</a></span></dt>
                     </dl>
                  </dd>
                  <dt><span class="section"><a href="ch03.html#d0e297">3.4. Replacing deprecated navigation methods</a></span></dt>
                  <dd>
                     <dl>
                        <dt><span class="section"><a href="ch03.html#d0e320">3.4.1. <span class="literal">navigateFollow()</span></a></span></dt>
                        <dt><span class="section"><a href="ch03.html#d0e375">3.4.2. <span class="literal">navigate()</span></a></span></dt>
                     </dl>
                  </dd>
               </dl>
            </div>
            <p>The server can move entities via either navigation functions, or a
                 simple <span class="literal">moveToPoint</span>.
            </p>
            <p>Navigation provides full path finding using special mesh data
                 generated by NavGen, while <span class="literal">moveToPoint</span> simply moves the
                 entity in a straight line, without taking obstacles or terrain into
                 account.
            </p>
            <div class="section" title="3.1.&nbsp;moveToPoint">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e118"></a>3.1.&nbsp;<span class="literal">moveToPoint</span></h2>
                     </div>
                  </div>
               </div>
               <p>This is the simplest movement system available &#8212; taking a
                      destination, it moves the entity in a straight line until that point is
                      reached.
               </p>
               <p>An example of an entity that uses this mechanism is the
                      <span class="literal">MovingPlatform</span> , which follows a series of patrol
                      nodes, using <span class="literal">moveToPoint</span> at each one to move to the
                      next.
               </p><pre class="programlisting">self.moveToPoint( self.patrolNode[1], self.travelSpeed, 0, self.faceDirection, True )</pre><p><span class="citetitle"><span class="literal">cell/MovingPlatform.py</span></span></p>
               <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>For details on the <code class="classname">MovingPlatform</code> entity,
                           see the document <a href="../howto_build_moving_platform/index.html" class="olink">How To Build a Server-Controlled Moving Platform</a>.
                  </p>
               </div>
            </div>
            <div class="section" title="3.2.&nbsp;Navigation">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e146"></a>3.2.&nbsp;Navigation
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Navigation is a path-finding service available to entities running
                      on the CellApps. Navigation uses a heuristically guided breadth first
                      search (A*), initially across the chunks, and then in the navigation mesh
                      within the chunks.
               </p>
               <p>For detailed information on all functions below, see the <a href="../..//api_python/cellapp/index.html" class="olink">CellApp Python API</a>.
               </p>
               <div class="section" title="3.2.1.&nbsp;canNavigateTo()">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e155"></a>3.2.1.&nbsp;<span class="literal">canNavigateTo()</span></h3>
                        </div>
                     </div>
                  </div>
                  <p>Before using any <span class="literal">navigate</span> function, you should
                           check that the destination can be reached. The function
                           <span class="literal">canNavigateTo</span> finds the nearest point to the
                           destination that can be reached by traversing the navigation mesh or
                           <span class="literal">None</span> if no path can be found. If navigation
                           is attempted to a point that cannot be reached, then an exception will
                           be raised by the <span class="literal">navigateStep</span> function.
                  </p>
               </div>
               <div class="section" title="3.2.2.&nbsp;navigateStep()">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e173"></a>3.2.2.&nbsp;<span class="literal">navigateStep()</span></h3>
                        </div>
                     </div>
                  </div>
                  <p>This function creates
                           a movement controller that moves the entity toward the destination. Each
                           time the entity enters a new navpoly, or travels the specified maximum
                           distance, the controller stops and calls the <span class="literal">onMove</span>
                           callback.
                  </p>
                  <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>The paths generated by calling <span class="literal">navigateStep</span>
                                are cached, making subsequent calls to the same destination
                                inexpensive.
                     </p>
                  </div>
                  <p>To reach the destination, you will have to re-call
                           <span class="literal">navigateStep</span> each time the entity stops.
                  </p><pre class="programlisting">self.controllerId = self.navigateStep( destination, velocity, maximumMovement ) </pre><p><span class="citetitle"><span class="literal">cell/Guard.py</span></span></p>
               </div>
               <div class="section" title="3.2.3.&nbsp;navigateFollow()">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e199"></a>3.2.3.&nbsp;<span class="literal">navigateFollow()</span></h3>
                        </div>
                     </div>
                  </div>
                  <p>NavigateFollow is an older function for navigating relative to
                           another entity's current position. New code should use
                           <span class="literal">navigateStep</span>.
                  </p>
               </div>
               <div class="section" title="3.2.4.&nbsp;navigate()">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e208"></a>3.2.4.&nbsp;<span class="literal">navigate()</span></h3>
                        </div>
                     </div>
                  </div>
                  <p>Navigate is an older function for navigating entities across
                           spaces. New code should use <span class="literal">navigateStep</span>.
                  </p>
               </div>
            </div>
            <div class="section" title="3.3.&nbsp;Example navigating cell entity">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e217"></a>3.3.&nbsp;Example navigating cell entity
                        </h2>
                     </div>
                  </div>
               </div>
               <p>To demonstrate the navigation mechanism, we have constructed a
                      simple example. The example entity randomly picks a location around its
                      current position, then navigates to it. Upon arrival, it chooses a new
                      destination and continues.
               </p>
               <div class="section" title="3.3.1.&nbsp;Loading">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e222"></a>3.3.1.&nbsp;Loading
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>The entity could be created before the rest of the chunk data is
                           loaded. If you use navigation immediately in the<span class="literal">
                              __init__</span> method, then the start location might be unresolved,
                           causing an exception. Instead, we wait for the navigation mesh to load,
                           using a timer and testing with <span class="literal">canNavigateTo</span>.
                  </p><pre class="programlisting">def __init__( self ):
 BigWorld.Entity .__init__( self )
 self.destination = self.position
 self.addTimer( 5.0, 0, RandomNavigator.TIMER_WAITING_FOR_NAVMESH )

def onTimer(self, timerId, userId):
 if self.canNavigateTo( self.position ) == None:
  self.addTimer( 5.0, 0, RandomNavigator.TIMER_WAITING_FOR_NAVMESH )
 else:
  self.navigateStep( self.destination, 5.0, 10.0 )</pre><p><span class="citetitle"><span class="literal">cell/RandomNavigator.py</span></span></p>
                  <p><span class="citetitle">Example navigation during chunk data
                              load</span></p>
               </div>
               <div class="section" title="3.3.2.&nbsp;Moving">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e242"></a>3.3.2.&nbsp;Moving
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Calling the first <span class="literal">navigateStep</span> will result in
                           the <span class="literal">onMove</span> callback being triggered. At this time,
                           the entity may or may not have reached its destination, so we check how
                           close the entity is. In this example, we require it to be within 0.1
                           metre of the target before picking a new destination.
                  </p>
                  <p>Note the use of <span class="literal">canNavigateTo</span> &#8212; this
                           function clamps the destination to the point closest to the destination,
                           and that is accessible via the navigation mesh. The entity then
                           perpetually follows this cycle of picking a destination, running to it
                           and then picking another.
                  </p><pre class="programlisting">def onMove(self, controllerId, userId):
 if ( self.position - self.destination ).length &gt; 0.1:
  self.navigateStep( self.destination, 5.0, 10.0 )
 else:
  self.destination = None
  while self.destination == None:
   randomDestination = ( 
    self.position.x + random.randrange(-400, 400, 1.0),
    self.position.y,
    self.position.z + random.randrange(-400, 400, 1.0) )
   self.destination = self.canNavigateTo( randomDestination )

  self.navigateStep( self.destination, 5.0, 10.0 ) </pre><p><span class="citetitle"><span class="literal">cell/RandomNavigator.py</span></span></p>
               </div>
               <div class="section" title="3.3.3.&nbsp;Client-side">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e264"></a>3.3.3.&nbsp;Client-side
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>To be able to correctly display the entity on the client machine,
                           we require two things:
                  </p>
                  <div class="itemizedlist">
                     <ul class="itemizedlist" type="disc">
                        <li class="listitem">
                           <p>A model.</p>
                        </li>
                        <li class="listitem">
                           <p>The correct filter.</p>
                        </li>
                     </ul>
                  </div>
                  <p>The default filter is <span class="literal">DumbFilter</span>, which simply
                           places the entity at the location most recently received from the
                           server, thus producing a stuttering motion as it moves about the world.
                           You might also notice that its height above the ground appears to go up
                           in steps &#8212; this is the movement of the entity on the server as it
                           traverses the navigation mesh covering slopes.
                  </p>
                  <p>Instead, we will use <span class="literal">AvatarDropFilter</span>, which
                           produces fluid movement for the Action Matcher, with the addition that
                           it locks the entity to the ground. For details on
                           <span class="literal">AvatarDropFilter</span>, see <a class="xref" href="ch04.html#xref_AvatarDropFilter" title="4.2.&nbsp;AvatarDropFilter"><code class="classname">AvatarDropFilter</code></a>.
                  </p><pre class="programlisting">def onEnterWorld( self, prereqs ):
 self.model = BigWorld.Model( RandomNavigator.stdModel )
 BigWorld.addShadowEntity( self )
 self.filter = BigWorld.AvatarDropFilter()

def onLeaveWorld( self ):
 BigWorld.delShadowEntity( self )
 self.model = None </pre><p><span class="citetitle"><span class="literal">client/RandomNavigator.py</span></span></p>
               </div>
            </div>
            <div class="section" title="3.4.&nbsp;Replacing deprecated navigation methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e297"></a>3.4.&nbsp;Replacing deprecated navigation methods
                        </h2>
                     </div>
                  </div>
               </div>
               <p>To show the method of converting an entity using either
                      <span class="literal">navigate</span> or <span class="literal">navigateFollow</span> to use
                      navigateStep, we have provided a simple example. It has two behaviours,
                      gated by a <span class="literal">think</span> method: A patrol behaviour, which moves
                      between two <span class="literal">UserDataObject</span>s using
                      <span class="literal">navigate</span> and a follow behaviour, which follows a supplied
                      entity ID, but stops and waits if it gets too close, using
                      <span class="literal">navigateFollow</span>.
               </p>
               <div class="section" title="3.4.1.&nbsp;navigateFollow()">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e320"></a>3.4.1.&nbsp;<span class="literal">navigateFollow()</span></h3>
                        </div>
                     </div>
                  </div>
                  <p><span class="literal">navigateFollow</span> was used to path to a point
                           relative to an entity. Here is a simple example of using
                           <span class="literal">navigateFollow</span> to follow an identified entity
                           around.
                  </p><pre class="programlisting"># Follow brain
	def follow( self ):
		# If self.targetID doesn't exist, switch to patrol mode
		if not BigWorld.entities.has_key( self.targetID ):
			self.stopFollow()
			return

		# If target isn't in this space, switch to patrol mode
		target = BigWorld.entities[ self.targetID ]
		if target.spaceID != self.spaceID:
			self.stopFollow()
			return

		# If we've arrived, wait here for target to move away
		if self.closeEnoughToTarget():
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# Follow our target
		target = BigWorld.entities[ self.targetID ]
		try:
			self.navigateFollow( target, FOLLOW_ANGLE, FOLLOW_DISTANCE, VELOCITY, 500, 500, True, 0.5 )
		except ValueError, e:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )

	def closeEnoughToTarget( self ):
		target = BigWorld.entities[ self.targetID ]
		return distance( self.position, target.position ) &lt;= FOLLOW_DISTANCE

	def onMove( self, controllerID, userData ):
		self.think()</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - Before</span></p>
                  <p>Since <span class="literal">navigateFollow</span> and
                           <span class="literal">navigateStep</span> share the same controller internally, the
                           changes are quite simple. We replace the block of code marked <span class="literal">#
                              Follow our target</span> with the following block of code:
                  </p><pre class="programlisting">		# Follow our target
		yaw = target.yaw + FOLLOW_ANGLE
		offset = ( FOLLOW_DISTANCE * math.sin( yaw ), 0, FOLLOW_DISTANCE * math.cos( yaw ) )
		dest = self.canNavigateTo( target.position + offset, 500, 0.5 )
		if dest is None:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return
		self.navigateStep( dest, VELOCITY, 500, 500, True, 0.5 )</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - After</span></p>
                  <p>The new calculation of <span class="literal">dest</span> is the same as that
                           performed by <span class="literal">navigateFollow</span> on the supplied entity.
                           We've also made use of the <span class="literal">canNavigateTo</span> method to
                           ensure that we attempt to navigate to a reachable spot, now that we have
                           access to the destination point.
                  </p>
                  <p>As should be clear here, <span class="literal">navigateStep</span> is a more
                           flexible interface to <span class="literal">navigateFollow</span>'s existing
                           behaviour, giving more control over movement behaviour and exposing the
                           intended destination to Python scripting code.
                  </p>
               </div>
               <div class="section" title="3.4.2.&nbsp;navigate()">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e375"></a>3.4.2.&nbsp;<span class="literal">navigate()</span></h3>
                        </div>
                     </div>
                  </div>
                  <p><span class="literal">navigate</span> was used to start an entity moving to a
                           target point, pathing along the navigation mesh, and would callback to the
                           entity when either the target point was reached, or if the navigation mesh
                           was unable to find a suitable path.  Here is a simple example of using
                           <span class="literal">navigate</span> to path between two points.
                  </p><pre class="programlisting">	# Patrol brain
	def patrol( self ):
		# If we haven't got any nodes, find a pair
		if self.nextNode is None:
			self.setupNodes()
		if self.nextNode is None:
			# If we can't find a pair of nodes, wait 5 seconds and try again
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# If we've arrived, turn around
		if self.closeEnoughToNode():
			self.swapNodes()

		# Navigate to slightly closer than self.closeEnoughToNode()
		self.navigate( self.nextNode.position, VELOCITY, True, 500, 0.5, PATROL_DISTANCE * 0.8 )

	def closeEnoughToNode( self ):
		target = self.nextNode
		return distance( self.position, target.position ) &lt;= PATROL_DISTANCE

	def setupNodes( self ):
		self.prevNode = None
		self.nextNode = None
		closest = None
		dist = 500
		for i in BigWorld.userDataObjects.values():
			if i.__class__.__name__ != "PatrolNode" or len(i.patrolLinks) == 0:
				continue
			if distance( self.position, i.position ) &lt; dist:
				closest = i
				dist = distance( self.position, i.position )
		if closest is not None:
			after = closest.patrolLinks[ 0 ]
			while distance( closest.position, after.position ) &lt; PATROL_DISTANCE * 3:
				after = after.patrolLinks[ 0 ]
				if after is None or after.uuid == closest.uuid:
					after = None
					break
			if after is not None:
				self.prevNode = closest
				self.nextNode = after

	def swapNodes( self ):
		temp = self.nextNode
		self.nextNode = self.prevNode
		self.prevNode = temp

	def onNavigate( self, controllerID, userData ):
		# Arrived. Turn around.
		self.swapNodes()
		self.think()
		
	def onNavigateFailed( self, controllerID, userData ):
		# Can't get there. Turn around
		self.swapNodes()
		self.think()</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - Before</span></p>
                  <p>Similarly to replacing <span class="literal">navigateFollow</span>, we can
                           replace the use of <span class="literal">navigate</span> very simply. We replace the
                           block of code marked <span class="literal"># Navigate to slightly closer than
                              self.closeEnoughToNode()</span> with the following block of
                           code:
                  </p><pre class="programlisting">		# Navigate towards self.nextNode.position
		dest = self.canNavigateTo( self.nextNode.position, 500, 0.5 )
		if dest is None:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return
		self.navigateStep( dest, VELOCITY, 500, 500, True, 0.5 )</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - After</span></p>
                  <p>We use the <span class="literal">canNavigateTo</span> method to identify a
                           waypoint position on the navigation mesh that matches our desired
                           destination, and then attempt to navigate towards it. This is similar to
                           what <span class="literal">navigate</span> does internally, except that we receive
                           an <span class="literal">onMove</span> callback every time we enter a new navpoly,
                           or have travelled the specified maximum distance.
                  </p>
                  <p>These more frequent callbacks allow the script-level code to control
                           navigation at a finer level, dealing with changed priorities or moving
                           targets without needing to either be triggered by an external event or
                           wait until the previously-selected destination is reached.
                  </p>
                  <p>At this point, the <span class="literal">onNavigate</span> callback is
                           unused, and can be removed. <span class="literal">onNavigateFailed</span> can be
                           renamed to <span class="literal">onMoveFailure</span>. <span class="literal">onMove</span>
                           remains unchanged, and simply calls <span class="literal">self.think()</span> as
                           seen in the above <span class="literal">navigateFollow</span> example.
                  </p>
                  <p>If <span class="literal">navigateStep</span> is called again during the
                           <span class="literal">onMove</span> callback, the existing
                           <span class="literal">Controller</span> will be reused if possible. This helps to
                           ensure that calling <span class="literal">navigateStep</span> more frequently than
                           <span class="literal">navigate</span> would be for the same navigation activity does
                           not cause extra load on the CellApp through repeated
                           <span class="literal">Controller</span> object creation.
                  </p>
               </div>
            </div>
         </div>
         <div class="navfooter">
            <hr class="navheaderline">
            <table width="95%" align="center" summary="Navigation footer">
               <tr>
                  <td width="38%" align="left"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;
                  </td>
                  <td width="20%" align="center">&nbsp;</td>
                  <td width="37%" align="right">&nbsp;<a accesskey="n" href="ch04.html">Next</a></td>
               </tr>
               <tr>
                  <td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Navigation Mesh&nbsp;</td>
                  <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
                  <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Filters</td>
               </tr>
               <tr>
                  <td colspan="3">Copyright 1999-2012 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.
                     		   
                  </td>
               </tr>
            </table>
         </div>
      </div>
   </body>
</html>