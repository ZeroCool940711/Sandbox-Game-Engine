<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>How To Move Entities</title><link rel="stylesheet" type="text/css" href="../css/bigworld.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="bigworld-header"><img src="http://try.bigworldtech.com/bigworld/image.php?img=bigworld_logo.gif&amp;svn=$HeadURL: http://patchsvn/svn/evaluation/official/IndiePackage/2.1/current/bigworld/doc/html/howto_move_entities/howto_move_entities.html $" alt="bw logo"></div><div id="content"><div class="book" title="How To Move Entities"><div class="titlepage"><div><div><h1 class="title"><a name="HowTo_Move_Entities"></a>How To Move Entities</h1></div><div><p class="releaseinfo">BigWorld Technology 2.1. Released 2012.</p></div><div><p class="copyright">Copyright &copy; 1999-2012 BigWorld Pty Ltd. All rights reserved. </p></div><div><div class="legalnotice" title="Legal Notice"><a name="d0e17"></a><p>This document is proprietary commercial in confidence and access
  is restricted to authorised users. This document is protected by
  copyright laws of Australia, other countries and international treaties.
  Unauthorised use, reproduction or distribution of this document, or any
  portion of this document, may result in the imposition of civil and
  criminal penalties as provided by law.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#xref_Introduction">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#xref_Navigation_Mesh">2. Navigation Mesh</a></span></dt><dt><span class="chapter"><a href="#xref_How_To_Move_Server_Controlled_Entities">3. How to Move Server-Controlled Entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e118">3.1. <span class="literal">moveToPoint</span></a></span></dt><dt><span class="section"><a href="#d0e146">3.2. Navigation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e155">3.2.1. <span class="literal">canNavigateTo()</span></a></span></dt><dt><span class="section"><a href="#d0e173">3.2.2. <span class="literal">navigateStep()</span></a></span></dt><dt><span class="section"><a href="#d0e199">3.2.3. <span class="literal">navigateFollow()</span></a></span></dt><dt><span class="section"><a href="#d0e208">3.2.4. <span class="literal">navigate()</span></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e217">3.3. Example navigating cell entity</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e222">3.3.1. Loading</a></span></dt><dt><span class="section"><a href="#d0e242">3.3.2. Moving</a></span></dt><dt><span class="section"><a href="#d0e264">3.3.3. Client-side</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e297">3.4. Replacing deprecated navigation methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e320">3.4.1. <span class="literal">navigateFollow()</span></a></span></dt><dt><span class="section"><a href="#d0e375">3.4.2. <span class="literal">navigate()</span></a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#xref_Filters">4. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#xref_AvatarFilter">4.1. <code class="classname">AvatarFilter</code></a></span></dt><dt><span class="section"><a href="#xref_AvatarDropFilter">4.2. <code class="classname">AvatarDropFilter</code></a></span></dt></dl></dd><dt><span class="chapter"><a href="#xref_How_To_Move_Client_Controlled_Entities">5. How to Move Client-Controlled Entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e520">5.1. <code class="methodname">seek()</code></a></span></dt><dd><dl><dt><span class="section"><a href="#d0e524">5.1.1. Mouse click movement</a></span></dt><dt><span class="section"><a href="#d0e549">5.1.2. Coordinated actions</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e565">5.2. <code class="methodname">chase()</code></a></span></dt><dd><dl><dt><span class="section"><a href="#d0e577">5.2.1. Handling the command</a></span></dt><dt><span class="section"><a href="#d0e591">5.2.2. Stopping the pursuit</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#xref_Source_Files">A. Source files</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e621">A.1. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e629">A.2. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e637">A.3. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e645">A.4. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/editor/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e653">A.5. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/entity_defs/RandomNavigator.def</span></a></span></dt><dt><span class="section"><a href="#d0e661">A.6. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/ElPolloDiablo.py</span></a></span></dt><dt><span class="section"><a href="#d0e669">A.7. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/ElPolloDiablo.py</span></a></span></dt><dt><span class="section"><a href="#d0e677">A.8. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/entity_defs/ElPolloDiablo.def</span></a></span></dt><dt><span class="section"><a href="#d0e685">A.9. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/ElPolloDiablo.py</span> - Before</a></span></dt><dt><span class="section"><a href="#d0e694">A.10. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/ElPolloDiablo.py</span> - After</a></span></dt></dl></dd></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="xref_Introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><p>Moving entities is one of the most fundamental processes in
  implementing a game. BigWorld provides two main mechanisms to accomplish
  this task: navigation and seeking.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><em class="emphasis">Navigation</em></p><p>This is the primary way to move NPCs (non-player characters)
      around the world. It uses a map of navigation information generated in
      an offline process, and can take into account the size of the
      entity.</p></li><li class="listitem"><p><em class="emphasis">Seek</em></p><p>This is a client-side function used to line up the player for
      interactions with other entities.</p></li></ul></div><p>Navigation can take into account the size of the navigating object,
  and thus follow paths that do not pass too close to obstacles. The
  pre-generated navigation information is known as the navigation mesh
  (navmesh), as it is a collection of polygons generated in an offline tool
  called NavGen (for details, see the <a href="../content_tools_reference_guide/content_tools_reference_guide#Content_Tools_Reference_Guide" class="olink">Content Tools Reference Guide</a>'s chapter <a href="../content_tools_reference_guide/content_tools_reference_guide#xref_NavGen" class="olink"><i>NavGen</i></a>).</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The NavGen's executable <span class="literal">navgen.exe</span> can be found
    under the <span class="literal">bigworld/tools/misc</span> folder.</p></div><p>This document describes the steps necessary to make an entity navigate
  from one point to another in a sensible manner, taking into account their
  environment.</p></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Navigation Mesh"><div class="titlepage"><div><div><h2 class="title"><a name="xref_Navigation_Mesh"></a>Chapter&nbsp;2.&nbsp;Navigation Mesh</h2></div></div></div><p>Use of the server-side navigation functions require the navigation
  mesh (or navmesh) be generated for the space. The navmesh is a collection of
  interconnected convex polygons parallel to the XZ plane. These
  <em class="emphasis">navpolys</em> are generated using the tool NavGen, and are
  stored in the <code class="filename">.cdata</code> chunk files of
  the space.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The chunk files are stored under the <code class="filename"><em class="replaceable"><code>&lt;res&gt;</code></em>/spaces/<em class="replaceable"><code>&lt;space&gt;</code></em></code>,
    and contain binary terrain and lighting data.</p><p>For details on the information held by this and other chunk files,
    see <a href="../client_programming_guide/client_programming_guide.html#Client_Programming_Guide" class="olink">Client Programming Guide</a>'s section <a href="../client_programming_guide/client_programming_guide.html#xref_Chunks" class="olink"><i>Chunks</i></a> <span class="symbol">&#8594;</span> <a href="../client_programming_guide/client_programming_guide.html#xref_Implementation_Files" class="olink">Implementation files</a>.</p><p>For details on this and other binary files' grammar, see <a href="../file_grammar_guide/file_grammar_guide.html#File_Grammar_Guide" class="olink">File Grammar Guide</a>'s section <a href="../file_grammar_guide/file_grammar_guide.html#xref_BinSection_Files" class="olink"><i><span class="literal">BinSection</span> files</i></a>.</p></div><p>For details on the generation of navmesh, see the document <a href="../content_tools_reference_guide/content_tools_reference_guide#Content_Tools_Reference_Guide" class="olink">Content Tools Reference Guide</a>'s section <a href="../content_tools_reference_guide/content_tools_reference_guide#xref_NavGen" class="olink"><i>NavGen</i></a> <span class="symbol">&#8594;</span> <a href="../content_tools_reference_guide/content_tools_reference_guide#xref_Generating_The_Navmesh" class="olink">Generating the navmesh</a>.</p></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;How to Move Server-Controlled Entities"><div class="titlepage"><div><div><h2 class="title"><a name="xref_How_To_Move_Server_Controlled_Entities"></a>Chapter&nbsp;3.&nbsp;How to Move Server-Controlled Entities</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e118">3.1. <span class="literal">moveToPoint</span></a></span></dt><dt><span class="section"><a href="#d0e146">3.2. Navigation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e155">3.2.1. <span class="literal">canNavigateTo()</span></a></span></dt><dt><span class="section"><a href="#d0e173">3.2.2. <span class="literal">navigateStep()</span></a></span></dt><dt><span class="section"><a href="#d0e199">3.2.3. <span class="literal">navigateFollow()</span></a></span></dt><dt><span class="section"><a href="#d0e208">3.2.4. <span class="literal">navigate()</span></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e217">3.3. Example navigating cell entity</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e222">3.3.1. Loading</a></span></dt><dt><span class="section"><a href="#d0e242">3.3.2. Moving</a></span></dt><dt><span class="section"><a href="#d0e264">3.3.3. Client-side</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e297">3.4. Replacing deprecated navigation methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e320">3.4.1. <span class="literal">navigateFollow()</span></a></span></dt><dt><span class="section"><a href="#d0e375">3.4.2. <span class="literal">navigate()</span></a></span></dt></dl></dd></dl></div><p>The server can move entities via either navigation functions, or a
  simple <span class="literal">moveToPoint</span>.</p><p>Navigation provides full path finding using special mesh data
  generated by NavGen, while <span class="literal">moveToPoint</span> simply moves the
  entity in a straight line, without taking obstacles or terrain into
  account.</p><div class="section" title="3.1.&nbsp;moveToPoint"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e118"></a>3.1.&nbsp;<span class="literal">moveToPoint</span></h2></div></div></div><p>This is the simplest movement system available &#8212; taking a
    destination, it moves the entity in a straight line until that point is
    reached.</p><p>An example of an entity that uses this mechanism is the
    <span class="literal">MovingPlatform</span> , which follows a series of patrol
    nodes, using <span class="literal">moveToPoint</span> at each one to move to the
    next.</p><pre class="programlisting">self.moveToPoint( self.patrolNode[1], self.travelSpeed, 0, self.faceDirection, True )</pre><p><span class="citetitle"><span class="literal">cell/MovingPlatform.py</span></span></p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For details on the <code class="classname">MovingPlatform</code> entity,
      see the document <a href="../howto_build_moving_platform/howto_build_moving_platform.html#HowTo_Moving_Platform" class="olink">How To Build a Server-Controlled Moving Platform</a>.</p></div></div><div class="section" title="3.2.&nbsp;Navigation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e146"></a>3.2.&nbsp;Navigation</h2></div></div></div><p>Navigation is a path-finding service available to entities running
    on the CellApps. Navigation uses a heuristically guided breadth first
    search (A*), initially across the chunks, and then in the navigation mesh
    within the chunks.</p><p>For detailed information on all functions below, see the <a href="../..//api_python/cellapp/index.html#Client_Python_API" class="olink">Client Python API</a>.</p><div class="section" title="3.2.1.&nbsp;canNavigateTo()"><div class="titlepage"><div><div><h3 class="title"><a name="d0e155"></a>3.2.1.&nbsp;<span class="literal">canNavigateTo()</span></h3></div></div></div><p>Before using any <span class="literal">navigate</span> function, you should
      check that the destination can be reached. The function
      <span class="literal">canNavigateTo</span> finds the nearest point to the
      destination that can be reached by traversing the navigation mesh or
      <span class="literal">None</span> if no path can be found. If navigation
      is attempted to a point that cannot be reached, then an exception will
      be raised by the <span class="literal">navigateStep</span> function.</p></div><div class="section" title="3.2.2.&nbsp;navigateStep()"><div class="titlepage"><div><div><h3 class="title"><a name="d0e173"></a>3.2.2.&nbsp;<span class="literal">navigateStep()</span></h3></div></div></div><p>This function creates
      a movement controller that moves the entity toward the destination. Each
      time the entity enters a new navpoly, or travels the specified maximum
      distance, the controller stops and calls the <span class="literal">onMove</span>
      callback.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The paths generated by calling <span class="literal">navigateStep</span>
        are cached, making subsequent calls to the same destination
        inexpensive.</p></div><p>To reach the destination, you will have to re-call
      <span class="literal">navigateStep</span> each time the entity stops.</p><pre class="programlisting">self.controllerId = self.navigateStep( destination, velocity, maximumMovement ) </pre><p><span class="citetitle"><span class="literal">cell/Guard.py</span></span></p></div><div class="section" title="3.2.3.&nbsp;navigateFollow()"><div class="titlepage"><div><div><h3 class="title"><a name="d0e199"></a>3.2.3.&nbsp;<span class="literal">navigateFollow()</span></h3></div></div></div><p>NavigateFollow is an older function for navigating relative to
      another entity's current position. New code should use
      <span class="literal">navigateStep</span>.</p></div><div class="section" title="3.2.4.&nbsp;navigate()"><div class="titlepage"><div><div><h3 class="title"><a name="d0e208"></a>3.2.4.&nbsp;<span class="literal">navigate()</span></h3></div></div></div><p>Navigate is an older function for navigating entities across
      spaces. New code should use <span class="literal">navigateStep</span>.</p></div></div><div class="section" title="3.3.&nbsp;Example navigating cell entity"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e217"></a>3.3.&nbsp;Example navigating cell entity</h2></div></div></div><p>To demonstrate the navigation mechanism, we have constructed a
    simple example. The example entity randomly picks a location around its
    current position, then navigates to it. Upon arrival, it chooses a new
    destination and continues.</p><div class="section" title="3.3.1.&nbsp;Loading"><div class="titlepage"><div><div><h3 class="title"><a name="d0e222"></a>3.3.1.&nbsp;Loading</h3></div></div></div><p>The entity could be created before the rest of the chunk data is
      loaded. If you use navigation immediately in the<span class="literal">
      __init__</span> method, then the start location might be unresolved,
      causing an exception. Instead, we wait for the navigation mesh to load,
      using a timer and testing with <span class="literal">canNavigateTo</span>.</p><pre class="programlisting">def __init__( self ):
 BigWorld.Entity .__init__( self )
 self.destination = self.position
 self.addTimer( 5.0, 0, RandomNavigator.TIMER_WAITING_FOR_NAVMESH )

def onTimer(self, timerId, userId):
 if self.canNavigateTo( self.position ) == None:
  self.addTimer( 5.0, 0, RandomNavigator.TIMER_WAITING_FOR_NAVMESH )
 else:
  self.navigateStep( self.destination, 5.0, 10.0 )</pre><p><span class="citetitle"><span class="literal">cell/RandomNavigator.py</span></span></p><p><span class="citetitle">Example navigation during chunk data
      load</span></p></div><div class="section" title="3.3.2.&nbsp;Moving"><div class="titlepage"><div><div><h3 class="title"><a name="d0e242"></a>3.3.2.&nbsp;Moving</h3></div></div></div><p>Calling the first <span class="literal">navigateStep</span> will result in
      the <span class="literal">onMove</span> callback being triggered. At this time,
      the entity may or may not have reached its destination, so we check how
      close the entity is. In this example, we require it to be within 0.1
      metre of the target before picking a new destination.</p><p>Note the use of <span class="literal">canNavigateTo</span> &#8212; this
      function clamps the destination to the point closest to the destination,
      and that is accessible via the navigation mesh. The entity then
      perpetually follows this cycle of picking a destination, running to it
      and then picking another.</p><pre class="programlisting">def onMove(self, controllerId, userId):
 if ( self.position - self.destination ).length &gt; 0.1:
  self.navigateStep( self.destination, 5.0, 10.0 )
 else:
  self.destination = None
  while self.destination == None:
   randomDestination = ( 
    self.position.x + random.randrange(-400, 400, 1.0),
    self.position.y,
    self.position.z + random.randrange(-400, 400, 1.0) )
   self.destination = self.canNavigateTo( randomDestination )

  self.navigateStep( self.destination, 5.0, 10.0 ) </pre><p><span class="citetitle"><span class="literal">cell/RandomNavigator.py</span></span></p></div><div class="section" title="3.3.3.&nbsp;Client-side"><div class="titlepage"><div><div><h3 class="title"><a name="d0e264"></a>3.3.3.&nbsp;Client-side</h3></div></div></div><p>To be able to correctly display the entity on the client machine,
      we require two things:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A model.</p></li><li class="listitem"><p>The correct filter.</p></li></ul></div><p>The default filter is <span class="literal">DumbFilter</span>, which simply
      places the entity at the location most recently received from the
      server, thus producing a stuttering motion as it moves about the world.
      You might also notice that its height above the ground appears to go up
      in steps &#8212; this is the movement of the entity on the server as it
      traverses the navigation mesh covering slopes.</p><p>Instead, we will use <span class="literal">AvatarDropFilter</span>, which
      produces fluid movement for the Action Matcher, with the addition that
      it locks the entity to the ground. For details on
      <span class="literal">AvatarDropFilter</span>, see <a class="xref" href="#xref_AvatarDropFilter" title="4.2.&nbsp;AvatarDropFilter"><code class="classname">AvatarDropFilter</code></a>.</p><pre class="programlisting">def onEnterWorld( self, prereqs ):
 self.model = BigWorld.Model( RandomNavigator.stdModel )
 BigWorld.addShadowEntity( self )
 self.filter = BigWorld.AvatarDropFilter()

def onLeaveWorld( self ):
 BigWorld.delShadowEntity( self )
 self.model = None </pre><p><span class="citetitle"><span class="literal">client/RandomNavigator.py</span></span></p></div></div><div class="section" title="3.4.&nbsp;Replacing deprecated navigation methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e297"></a>3.4.&nbsp;Replacing deprecated navigation methods</h2></div></div></div><p>To show the method of converting an entity using either
    <span class="literal">navigate</span> or <span class="literal">navigateFollow</span> to use
    navigateStep, we have provided a simple example. It has two behaviours,
    gated by a <span class="literal">think</span> method: A patrol behaviour, which moves
    between two <span class="literal">UserDataObject</span>s using
    <span class="literal">navigate</span> and a follow behaviour, which follows a supplied
    entity ID, but stops and waits if it gets too close, using
    <span class="literal">navigateFollow</span>.</p><div class="section" title="3.4.1.&nbsp;navigateFollow()"><div class="titlepage"><div><div><h3 class="title"><a name="d0e320"></a>3.4.1.&nbsp;<span class="literal">navigateFollow()</span></h3></div></div></div><p><span class="literal">navigateFollow</span> was used to path to a point
      relative to an entity. Here is a simple example of using
      <span class="literal">navigateFollow</span> to follow an identified entity
      around.</p><pre class="programlisting"># Follow brain
	def follow( self ):
		# If self.targetID doesn't exist, switch to patrol mode
		if not BigWorld.entities.has_key( self.targetID ):
			self.stopFollow()
			return

		# If target isn't in this space, switch to patrol mode
		target = BigWorld.entities[ self.targetID ]
		if target.spaceID != self.spaceID:
			self.stopFollow()
			return

		# If we've arrived, wait here for target to move away
		if self.closeEnoughToTarget():
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# Follow our target
		target = BigWorld.entities[ self.targetID ]
		try:
			self.navigateFollow( target, FOLLOW_ANGLE, FOLLOW_DISTANCE, VELOCITY, 500, 500, True, 0.5 )
		except ValueError, e:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )

	def closeEnoughToTarget( self ):
		target = BigWorld.entities[ self.targetID ]
		return distance( self.position, target.position ) &lt;= FOLLOW_DISTANCE

	def onMove( self, controllerID, userData ):
		self.think()</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - Before</span></p><p>Since <span class="literal">navigateFollow</span> and
      <span class="literal">navigateStep</span> share the same controller internally, the
      changes are quite simple. We replace the block of code marked <span class="literal">#
      Follow our target</span> with the following block of code:</p><pre class="programlisting">		# Follow our target
		yaw = target.yaw + FOLLOW_ANGLE
		offset = ( FOLLOW_DISTANCE * math.sin( yaw ), 0, FOLLOW_DISTANCE * math.cos( yaw ) )
		dest = self.canNavigateTo( target.position + offset, 500, 0.5 )
		if dest is None:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return
		self.navigateStep( dest, VELOCITY, 500, 500, True, 0.5 )</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - After</span></p><p>The new calculation of <span class="literal">dest</span> is the same as that
      performed by <span class="literal">navigateFollow</span> on the supplied entity.
      We've also made use of the <span class="literal">canNavigateTo</span> method to
      ensure that we attempt to navigate to a reachable spot, now that we have
      access to the destination point.</p><p>As should be clear here, <span class="literal">navigateStep</span> is a more
      flexible interface to <span class="literal">navigateFollow</span>'s existing
      behaviour, giving more control over movement behaviour and exposing the
      intended destination to Python scripting code.</p></div><div class="section" title="3.4.2.&nbsp;navigate()"><div class="titlepage"><div><div><h3 class="title"><a name="d0e375"></a>3.4.2.&nbsp;<span class="literal">navigate()</span></h3></div></div></div><p><span class="literal">navigate</span> was used to start an entity moving to a
      target point, pathing along the navigation mesh, and would callback to the
      entity when either the target point was reached, or if the navigation mesh
      was unable to find a suitable path.  Here is a simple example of using
      <span class="literal">navigate</span> to path between two points.</p><pre class="programlisting">	# Patrol brain
	def patrol( self ):
		# If we haven't got any nodes, find a pair
		if self.nextNode is None:
			self.setupNodes()
		if self.nextNode is None:
			# If we can't find a pair of nodes, wait 5 seconds and try again
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# If we've arrived, turn around
		if self.closeEnoughToNode():
			self.swapNodes()

		# Navigate to slightly closer than self.closeEnoughToNode()
		self.navigate( self.nextNode.position, VELOCITY, True, 500, 0.5, PATROL_DISTANCE * 0.8 )

	def closeEnoughToNode( self ):
		target = self.nextNode
		return distance( self.position, target.position ) &lt;= PATROL_DISTANCE

	def setupNodes( self ):
		self.prevNode = None
		self.nextNode = None
		closest = None
		dist = 500
		for i in BigWorld.userDataObjects.values():
			if i.__class__.__name__ != "PatrolNode" or len(i.patrolLinks) == 0:
				continue
			if distance( self.position, i.position ) &lt; dist:
				closest = i
				dist = distance( self.position, i.position )
		if closest is not None:
			after = closest.patrolLinks[ 0 ]
			while distance( closest.position, after.position ) &lt; PATROL_DISTANCE * 3:
				after = after.patrolLinks[ 0 ]
				if after is None or after.uuid == closest.uuid:
					after = None
					break
			if after is not None:
				self.prevNode = closest
				self.nextNode = after

	def swapNodes( self ):
		temp = self.nextNode
		self.nextNode = self.prevNode
		self.prevNode = temp

	def onNavigate( self, controllerID, userData ):
		# Arrived. Turn around.
		self.swapNodes()
		self.think()
		
	def onNavigateFailed( self, controllerID, userData ):
		# Can't get there. Turn around
		self.swapNodes()
		self.think()</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - Before</span></p><p>Similarly to replacing <span class="literal">navigateFollow</span>, we can
      replace the use of <span class="literal">navigate</span> very simply. We replace the
      block of code marked <span class="literal"># Navigate to slightly closer than
      self.closeEnoughToNode()</span> with the following block of
      code:</p><pre class="programlisting">		# Navigate towards self.nextNode.position
		dest = self.canNavigateTo( self.nextNode.position, 500, 0.5 )
		if dest is None:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return
		self.navigateStep( dest, VELOCITY, 500, 500, True, 0.5 )</pre><p><span class="citetitle"><span class="literal">cell/ElPolloDiablo.py</span> - After</span></p><p>We use the <span class="literal">canNavigateTo</span> method to identify a
      waypoint position on the navigation mesh that matches our desired
      destination, and then attempt to navigate towards it. This is similar to
      what <span class="literal">navigate</span> does internally, except that we receive
      an <span class="literal">onMove</span> callback every time we enter a new navpoly,
      or have travelled the specified maximum distance.</p><p>These more frequent callbacks allow the script-level code to control
      navigation at a finer level, dealing with changed priorities or moving
      targets without needing to either be triggered by an external event or
      wait until the previously-selected destination is reached.</p><p>At this point, the <span class="literal">onNavigate</span> callback is
      unused, and can be removed. <span class="literal">onNavigateFailed</span> can be
      renamed to <span class="literal">onMoveFailure</span>. <span class="literal">onMove</span>
      remains unchanged, and simply calls <span class="literal">self.think()</span> as
      seen in the above <span class="literal">navigateFollow</span> example.</p><p>If <span class="literal">navigateStep</span> is called again during the
      <span class="literal">onMove</span> callback, the existing
      <span class="literal">Controller</span> will be reused if possible. This helps to
      ensure that calling <span class="literal">navigateStep</span> more frequently than
      <span class="literal">navigate</span> would be for the same navigation activity does
      not cause extra load on the CellApp through repeated
      <span class="literal">Controller</span> object creation.</p></div></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Filters"><div class="titlepage"><div><div><h2 class="title"><a name="xref_Filters"></a>Chapter&nbsp;4.&nbsp;Filters</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#xref_AvatarFilter">4.1. <code class="classname">AvatarFilter</code></a></span></dt><dt><span class="section"><a href="#xref_AvatarDropFilter">4.2. <code class="classname">AvatarDropFilter</code></a></span></dt></dl></div><p>Although an in-depth look at filters is beyond the scope of this
  document, it is important to mention their existence at this point.</p><p>Filters process position and rotation updates from the server into a
  smooth movement on the client machine. They can also be used to make
  assumptions about the movement of entities, as is the case with
  <code class="classname">AvatarDropFilter</code><sup>[<a name="d0e473" href="#ftn.d0e473" class="footnote">1</a>]</sup>.</p><div class="section" title="4.1.&nbsp;AvatarFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xref_AvatarFilter"></a>4.1.&nbsp;<code class="classname">AvatarFilter</code></h2></div></div></div><p>This filter produces movement on the client that corresponds to the
    one on the server.</p><p>Use this filter for entities that do not remain stuck to the ground,
    such as other players and flying vehicles.</p></div><div class="section" title="4.2.&nbsp;AvatarDropFilter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xref_AvatarDropFilter"></a>4.2.&nbsp;<code class="classname">AvatarDropFilter</code></h2></div></div></div><p>This filter places the client-side entity on the ground, even if the
    server places it in the air.</p><p>It is suitable for entities using navigation, as the navigation mesh
    is always slightly raised above the terrain.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d0e473" href="#d0e473" class="para">1</a>] </sup>For details, see the <a href="../..//api_python/client/index.html#Client_Python_API" class="olink">Client Python API</a>'s
      entries Class List <span class="symbol">&#8594;</span>
      <code class="classname">AvatarDropFilter</code> and Class List <span class="symbol">&#8594;</span>
      <code class="classname">AvatarFilter</code>.</p></div></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;How to Move Client-Controlled Entities"><div class="titlepage"><div><div><h2 class="title"><a name="xref_How_To_Move_Client_Controlled_Entities"></a>Chapter&nbsp;5.&nbsp;How to Move Client-Controlled Entities</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e520">5.1. <code class="methodname">seek()</code></a></span></dt><dd><dl><dt><span class="section"><a href="#d0e524">5.1.1. Mouse click movement</a></span></dt><dt><span class="section"><a href="#d0e549">5.1.2. Coordinated actions</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e565">5.2. <code class="methodname">chase()</code></a></span></dt><dd><dl><dt><span class="section"><a href="#d0e577">5.2.1. Handling the command</a></span></dt><dt><span class="section"><a href="#d0e591">5.2.2. Stopping the pursuit</a></span></dt></dl></dd></dl></div><p>All client-side movement is done using the physics object that acts
  like a controller, sending position updates to the server.</p><p>The navigation mesh is not present on the client, so the functions
  <code class="methodname">seek()</code> and <code class="methodname">chase()</code> must be
  used. They provide simple direct movement, following the terrain and
  colliding with obstacles.</p><div class="section" title="5.1.&nbsp;seek()"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e520"></a>5.1.&nbsp;<code class="methodname">seek()</code></h2></div></div></div><div class="section" title="5.1.1.&nbsp;Mouse click movement"><div class="titlepage"><div><div><h3 class="title"><a name="d0e524"></a>5.1.1.&nbsp;Mouse click movement</h3></div></div></div><p>In this example we will use <span class="literal">seek</span> to implement a
      simple mouse click-based movement.</p><p>To access this functionality in the FantasyDemo, press
      <span class="literal">Z</span> to bring up the cursor, and right-click on the
      terrain to move.</p><pre class="programlisting">def moveKey( self, isDown ):
 if isDown:
  mp = GUI.mcursor().position
  type, target = collide.collide( mp.x, mp.y )
  if type == collide.COLLIDE_TERRAIN:
   self._movePlayer( target )
  elif type == collide.COLLIDE_ENTITY:
   self._movePlayer( target.position )

def _movePlayer( self, position ):
 player   = BigWorld.player()
 velocity = player.runFwdSpeed
 timeout  = 1.5 * (position - player.position).length / velocity
 curr_yaw = (position - player.position).yaw
 destination = (position[0], position[1], position[2], curr_yaw)
 player.physics.velocity = (0, 0, velocity)
 player.physics.seek( destination, timeout, 10, self._seekCallback )
 self.isMoving = True</pre><p><span class="citetitle"><code class="filename">client/MouseControl.py</code></span></p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The destination needed by <code class="methodname">seek()</code> is a
        four-member tuple containing the position and yaw.</p></div></div><div class="section" title="5.1.2.&nbsp;Coordinated actions"><div class="titlepage"><div><div><h3 class="title"><a name="d0e549"></a>5.1.2.&nbsp;Coordinated actions</h3></div></div></div><p>The <span class="literal">seek</span> method is often used in conjunction
      with coordinated actions. These are actions involving two models, such
      as a handshake.</p><p>The position and yaw needed for the actions to line up can be
      extracted from the action, as in the following excerpt:</p><pre class="programlisting">self.physics.seek( partner.model.Shake_B_Accept.seekInv, 5.0, 0.10, onSeek )
self.physics.velocity = ( 0, 0, self.walkFwdSpeed )</pre><p><span class="citetitle"><span class="literal">client/Avatar.py</span></span></p></div></div><div class="section" title="5.2.&nbsp;chase()"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e565"></a>5.2.&nbsp;<code class="methodname">chase()</code></h2></div></div></div><p>To demonstrate the <span class="literal">chase</span> function we will
    implement a <span class="literal">/follow</span> chat console command in
    FantasyDemo. The command will cause the player to follow the targeted
    entity, until they press a movement key breaking the pursuit.</p><div class="section" title="5.2.1.&nbsp;Handling the command"><div class="titlepage"><div><div><h3 class="title"><a name="d0e577"></a>5.2.1.&nbsp;Handling the command</h3></div></div></div><p>The Fantasy Demo chat console will automatically resolve the typed
      &#8216;/follow&#8217; command to a function call. All we need to do is add the
      following function to the <span class="literal">ConsoleCommands.py</span>
      module.</p><pre class="programlisting">def follow( player, string ):
    # Follow the current target
    if BigWorld.target() != None:
        player.physics.chase( BigWorld.target(), 2.0, 0.5 )
        player.physics.velocity = ( 0, 0, 6.0 )</pre><p><span class="citetitle"><span class="literal">client/Helpers/ConsoleCommands.py</span></span></p></div><div class="section" title="5.2.2.&nbsp;Stopping the pursuit"><div class="titlepage"><div><div><h3 class="title"><a name="d0e591"></a>5.2.2.&nbsp;Stopping the pursuit</h3></div></div></div><p>To cancel the chase action, we need to add the code below to
      <span class="literal">PlayerAvatar</span>'s <span class="literal">moveForward</span>,
      <span class="literal">moveBackward</span>, <span class="literal">moveLeft</span> and
      <span class="literal">moveRight</span> functions as in the excerpt below.</p><pre class="programlisting">def moveForward(self, isDown):
    if isDown:
        if self.mouseControl.isMoving:
            self.mouseControl.cancel()
        
        if self.physics.chasing:
            self.physics.stop()

        self.forwardMagnitude = min(self.forwardMagnitude+1.0,1.0)
        if self.mode == Mode.COMBAT_CLOSE:
            if self.stance == Avatar.STANCE_BACKWARD:
                nst = Avatar.STANCE_NEUTRAL
            else:
                nst = Avatar.STANCE_FORWARD
            self.takeStance( nst )
    else:
        self.forwardMagnitude = max(self.forwardMagnitude-1.0,-1.0)</pre><p><span class="citetitle"><span class="literal">client/Avatar.py</span></span></p></div></div></div><div class="appendix" title="Appendix&nbsp;A.&nbsp;Source files"><div class="titlepage"><div><div><h2 class="title"><a name="xref_Source_Files"></a>Appendix&nbsp;A.&nbsp;Source files</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e621">A.1. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e629">A.2. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e637">A.3. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e645">A.4. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/editor/RandomNavigator.py</span></a></span></dt><dt><span class="section"><a href="#d0e653">A.5. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/entity_defs/RandomNavigator.def</span></a></span></dt><dt><span class="section"><a href="#d0e661">A.6. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/ElPolloDiablo.py</span></a></span></dt><dt><span class="section"><a href="#d0e669">A.7. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/ElPolloDiablo.py</span></a></span></dt><dt><span class="section"><a href="#d0e677">A.8. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/entity_defs/ElPolloDiablo.def</span></a></span></dt><dt><span class="section"><a href="#d0e685">A.9. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/ElPolloDiablo.py</span> - Before</a></span></dt><dt><span class="section"><a href="#d0e694">A.10. <span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/ElPolloDiablo.py</span> - After</a></span></dt></dl></div><div class="section" title="A.1.&nbsp;<res&gt;/scripts/cell/RandomNavigator.py"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e621"></a>A.1.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/RandomNavigator.py</span></h2></div></div></div><pre class="programlisting">import BigWorld
import math
import random
import Math


class RandomNavigator( BigWorld.Entity ):

    TIMER_WAITING_FOR_NAVMESH = 1
    
    #---------------------------------------------------------------------
    # Constructor.
    #---------------------------------------------------------------------
    def __init__( self ):
        BigWorld.Entity .__init__( self )
        self.destination = self.position
        self.addTimer( 5.0, 0, RandomNavigator.TIMER_WAITING_FOR_NAVMESH )

    #---------------------------------------------------------------------
    # This method is called when a timer expires.
    #---------------------------------------------------------------------
    def onTimer(self, timerId, userId):
        if userId == RandomNavigator.TIMER_WAITING_FOR_NAVMESH:
            if self.canNavigateTo( self.position ) == None:
                self.addTimer( 5.0, 0, RandomNavigator.TIMER_WAITING_FOR_NAVMESH )
            else:
                self.navigateStep( self.destination, 5.0, 10.0 )


    #---------------------------------------------------------------------
    # This method is called when we've finished moving to a point.
    #---------------------------------------------------------------------
    def onMove(self, controllerId, userId):
        if ( self.position - self.destination ).length &gt; 0.1:
            self.navigateStep( self.destination, 5.0, 10.0 )
        else:
            self.destination = None
            while self.destination == None:
                randomDestination = ( 
                    self.position.x + random.randrange(-400, 400, 1.0),
                    self.position.y,
                    self.position.z + random.randrange(-400, 400, 1.0) )
                self.destination = self.canNavigateTo( randomDestination )

            self.navigateStep( self.destination, 5.0, 10.0 )

# RandomNavigator.py</pre></div><div class="section" title="A.2.&nbsp;<res&gt;/scripts/client/RandomNavigator.py"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e629"></a>A.2.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/RandomNavigator.py</span></h2></div></div></div><pre class="programlisting">import math
import BigWorld
from keys import *


# --------------------------------------------------------------------------
# Section: class RandomNavigator
# --------------------------------------------------------------------------


class RandomNavigator( BigWorld.Entity ):
    stdModel = 'characters/avatars/base/base.model'

    def __init__( self ):
        BigWorld.Entity.__init__( self )


    def prerequisites( self ):
        return [ RandomNavigator.stdModel ]


    def enterWorld( self ):
        self.model = BigWorld.Model( RandomNavigator.stdModel )
        BigWorld.addShadowEntity( self )
        self.targetCaps = [ CAP_CAN_HIT , CAP_CAN_USE ]
        self.filter = BigWorld.AvatarDropFilter()
        

    def leaveWorld( self ):
        BigWorld.delShadowEntity( self )
        self.model = None


    def use( self ):
        pass


#RandomNavigator.py</pre></div><div class="section" title="A.3.&nbsp;<res&gt;/scripts/base/RandomNavigator.py"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e637"></a>A.3.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/RandomNavigator.py</span></h2></div></div></div><pre class="programlisting">import FantasyDemo

# --------------------------------------------------------------------------
# Section: class RandomNavigator
# --------------------------------------------------------------------------

class RandomNavigator( FantasyDemo.Base ):

    def __init__( self ):
        FantasyDemo.Base.__init__( self )


# RandomNavigator.py  </pre></div><div class="section" title="A.4.&nbsp;<res&gt;/scripts/editor/RandomNavigator.py"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e645"></a>A.4.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/editor/RandomNavigator.py</span></h2></div></div></div><pre class="programlisting">class RandomNavigator:
    def modelName( self, props ):
        return 'characters/avatars/base/base.model'

# RandomNavigator.py</pre></div><div class="section" title="A.5.&nbsp;<res&gt;/scripts/entity_defs/RandomNavigator.def"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e653"></a>A.5.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/entity_defs/RandomNavigator.def</span></h2></div></div></div><pre class="programlisting">&lt;root&gt;
    &lt;Volatile&gt;
        &lt;position/&gt;
        &lt;yaw/&gt;
    &lt;/Volatile&gt;

    &lt;Properties&gt;

        &lt;destination&gt;
            &lt;Type&gt;            PYTHON                &lt;/Type&gt;
            &lt;Flags&gt;            CELL_PRIVATE        &lt;/Flags&gt;
        &lt;/destination&gt;

    &lt;/Properties&gt;

    &lt;ClientMethods&gt;
    &lt;/ClientMethods&gt;

    &lt;CellMethods&gt;
    &lt;/CellMethods&gt;
&lt;/root&gt;</pre></div><div class="section" title="A.6.&nbsp;<res&gt;/scripts/base/ElPolloDiablo.py"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e661"></a>A.6.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/base/ElPolloDiablo.py</span></h2></div></div></div><pre class="programlisting"> import FantasyDemo

# -------------------------------------------------------------------
# Section: class ElPolloDiablo
# -------------------------------------------------------------------

class ElPolloDiablo( FantasyDemo.Base ):
	pass

# ElPolloDiablo.py</pre></div><div class="section" title="A.7.&nbsp;<res&gt;/scripts/client/ElPolloDiablo.py"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e669"></a>A.7.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/client/ElPolloDiablo.py</span></h2></div></div></div><pre class="programlisting">import BigWorld

MODEL = "characters/npc/chicken/chicken.model"

# -------------------------------------------------------------------
# Class ElPolloDiablo:
#
# ElPolloDiablo follows an entity, or wanders between two patrol nodes
# -------------------------------------------------------------------
class ElPolloDiablo(BigWorld.Entity):

	# -----------------------------------------------------------------
	# Method: __init__
	# Description:
	#	- Defines all variables used by the entity. This includes
	#	  setting variables to None.
	#	- Does not call any of the accessor methods. Any variables set are
	#	  for the purposes of stability.
	# ------------------------------------------------------------------
	def __init__( self ):
		BigWorld.Entity.__init__( self )
		self.filter = BigWorld.AvatarDropFilter()
		self.model = None


	# ------------------------------------------------------------------
	# Method: prerequisites
	# Description:
	#	- Return a list of the resources that we want loaded in the background
	#	for us before onEnterWorld() is called.
	# ------------------------------------------------------------------
	def prerequisites( self ):
		return [ MODEL ]


	# ------------------------------------------------------------------
	# Method: onEnterWorld
	# Description:
	#	- Creates a model for the ElPolloDiablo.
	# ------------------------------------------------------------------
	def onEnterWorld( self, prereqs ):
		self.model = prereqs[ MODEL ]
		self.model.scale = (4.0, 4.0, 4.0)


	# ------------------------------------------------------------------
	# This method is called when the entity leaves the world
	# ------------------------------------------------------------------
	def onLeaveWorld( self ):
		self.model = None


	# ------------------------------------------------------------------
	# Method: name
	# Description:
	#	- Part of the entity interface: This allows the client to get a string
	#	  name for the entity.
	# ------------------------------------------------------------------
	def name( self ):
		return "El Pollo Diablo"

#ElPolloDiablo.py</pre></div><div class="section" title="A.8.&nbsp;<res&gt;/scripts/entity_defs/ElPolloDiablo.def"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e677"></a>A.8.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/entity_defs/ElPolloDiablo.def</span></h2></div></div></div><pre class="programlisting">&lt;root&gt;
	&lt;Volatile&gt;
		&lt;position/&gt;
		&lt;yaw/&gt;
	&lt;/Volatile&gt;

	&lt;Implements&gt;
		&lt;Interface&gt; BaseAndCell &lt;/Interface&gt;
	&lt;/Implements&gt;

	&lt;Properties&gt;
		&lt;!-- 0 is wander, 1 is follow targetID --&gt;
		&lt;mode&gt;
			&lt;Type&gt;		INT32		&lt;/Type&gt;
			&lt;Flags&gt;		CELL_PRIVATE		&lt;/Flags&gt;
			&lt;Persistent&gt;	false		&lt;/Persistent&gt;
			&lt;Default&gt;	0		&lt;/Default&gt;
		&lt;/mode&gt;

		&lt;targetID&gt;
			&lt;Type&gt;		OBJECT_ID		&lt;/Type&gt;
			&lt;Flags&gt;		CELL_PRIVATE		&lt;/Flags&gt;
			&lt;Persistent&gt;	false		&lt;/Persistent&gt;
		&lt;/targetID&gt;

		&lt;nextNode&gt;
			&lt;Type&gt;		PATROL_NODE		&lt;/Type&gt;
			&lt;Flags&gt;		CELL_PRIVATE		&lt;/Flags&gt;
			&lt;Persistent&gt;	false		&lt;/Persistent&gt;
		&lt;/nextNode&gt;

		&lt;prevNode&gt;
			&lt;Type&gt;		PATROL_NODE		&lt;/Type&gt;
			&lt;Flags&gt;		CELL_PRIVATE		&lt;/Flags&gt;
			&lt;Persistent&gt;	false		&lt;/Persistent&gt;
		&lt;/prevNode&gt;
	&lt;/Properties&gt;

	&lt;ClientMethods&gt;
	&lt;/ClientMethods&gt;

	&lt;CellMethods&gt;
		&lt;startFollow&gt;
			&lt;Args&gt;
				&lt;id&gt;		OBJECT_ID		&lt;/id&gt;	&lt;!-- EntityID --&gt;
			&lt;/Args&gt;
		&lt;/startFollow&gt;

		&lt;stopFollow&gt;
		&lt;/stopFollow&gt;
	&lt;/CellMethods&gt;

	&lt;BaseMethods&gt;
	&lt;/BaseMethods&gt;

&lt;/root&gt;</pre></div><div class="section" title="A.9.&nbsp;<res&gt;/scripts/cell/ElPolloDiablo.py - Before"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e685"></a>A.9.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/ElPolloDiablo.py</span> - Before</h2></div></div></div><pre class="programlisting">"This module implements the ElPolloDiablo entity."

# BigWorld Modules
import BigWorld

# Python modules
import random
import math

#todo: replace this with math module
def distance(v1, v2):
	"Returns the distance between two 3d vectors"
	x = v2[0] - v1[0]
	z = v2[2] - v1[2]
	#ignore y value due to the current 13k hack
	return math.sqrt(x * x + z * z)


# ----------------------------------------------------------------------------
# Section: class ElPolloDiablo
# ----------------------------------------------------------------------------
class ElPolloDiablo( BigWorld.Entity ):
	"An ElPolloDiablo entity."

	PATROL_MODE		= 0
	FOLLOW_MODE		= 1

	VELOCITY		= 20

	PATROL_DISTANCE		= 2

	FOLLOW_DISTANCE		= 10
	FOLLOW_ANGLE		= math.pi

	#------------------------------------------------------------------------
	# Constructor
	#------------------------------------------------------------------------

	def __init__( self ):
		BigWorld.Entity.__init__( self )

		# random yaw
		yaw = random.uniform(-math.pi, math.pi)

		self.direction = (0.0, 0.0, yaw)

		if self.mode == ElPolloDiablo.PATROL_MODE:
			self.stopFollow()
		else:
			self.startFollow( self.targetID )

	def onTimer( self, controllerID, userData ):
		self.think()

	def startFollow( self, targetID ):
		self.mode = ElPolloDiablo.FOLLOW_MODE
		self.targetID = targetID
		self.cancel( "Movement" )
		self.think()

	def stopFollow( self ):
		self.mode = ElPolloDiablo.PATROL_MODE
		self.nextNode = None
		self.cancel( "Movement" )
		self.think()

	def think( self ):
		if self.mode == ElPolloDiablo.PATROL_MODE:
			self.patrol()
		else:
			self.follow()


	# Patrol brain
	def patrol( self ):
		# If we haven't got any nodes, find a pair
		if self.nextNode is None:
			self.setupNodes()
		if self.nextNode is None:
			# If we can't find a pair of nodes, wait 5 seconds and try again
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# If we've arrived, turn around
		if self.closeEnoughToNode():
			self.swapNodes()

		# Navigate to slightly closer than self.closeEnoughToNode()
		self.navigate( self.nextNode.position, ElPolloDiablo.VELOCITY, True, 500, 0.5, ElPolloDiablo.PATROL_DISTANCE * 0.8 )

	def closeEnoughToNode( self ):
		target = self.nextNode
		return distance( self.position, target.position ) &lt;= ElPolloDiablo.PATROL_DISTANCE

	def setupNodes( self ):
		self.prevNode = None
		self.nextNode = None
		closest = None
		dist = 500
		for i in BigWorld.userDataObjects.values():
			if i.__class__.__name__ != "PatrolNode" or len(i.patrolLinks) == 0:
				continue
			if distance( self.position, i.position ) &lt; dist:
				closest = i
				dist = distance( self.position, i.position )
		if closest is not None:
			after = closest.patrolLinks[ 0 ]
			while distance( closest.position, after.position ) &lt; ElPolloDiablo.PATROL_DISTANCE * 3:
				after = after.patrolLinks[ 0 ]
				if after is None or after.uuid == closest.uuid:
					after = None
					break
			if after is not None:
				self.prevNode = closest
				self.nextNode = after

	def swapNodes( self ):
		temp = self.nextNode
		self.nextNode = self.prevNode
		self.prevNode = temp

	def onNavigate( self, controllerID, userData ):
		# Arrived. Turn around.
		self.swapNodes()
		self.think()
		
	def onNavigateFailed( self, controllerID, userData ):
		# Can't get there. Turn around
		self.swapNodes()
		self.think()


	# Follow brain
	def follow( self ):
		# If self.targetID doesn't exist, switch to patrol mode
		if not BigWorld.entities.has_key( self.targetID ):
			self.stopFollow()
			return

		# If target isn't in this space, switch to patrol mode
		target = BigWorld.entities[ self.targetID ]
		if target.spaceID != self.spaceID:
			self.stopFollow()
			return

		# If we've arrived, wait here for target to move away
		if self.closeEnoughToTarget():
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# Follow our target
		target = BigWorld.entities[ self.targetID ]
		try:
			self.navigateFollow( target, ElPolloDiablo.FOLLOW_ANGLE, ElPolloDiablo.FOLLOW_DISTANCE, ElPolloDiablo.VELOCITY, 500, 500, True, 0.5 )
		except ValueError, e:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )

	def closeEnoughToTarget( self ):
		target = BigWorld.entities[ self.targetID ]
		return distance( self.position, target.position ) &lt;= ElPolloDiablo.FOLLOW_DISTANCE

	def onMove( self, controllerID, userData ):
		self.think()

# ElPolloDiablo.py</pre></div><div class="section" title="A.10.&nbsp;<res&gt;/scripts/cell/ElPolloDiablo.py - After"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e694"></a>A.10.&nbsp;<span class="literal"><em class="replaceable"><code>&lt;res&gt;</code></em>/scripts/cell/ElPolloDiablo.py</span> - After</h2></div></div></div><pre class="programlisting">"This module implements the ElPolloDiablo entity."

# BigWorld Modules
import BigWorld

# Python modules
import random
import math

#todo: replace this with math module
def distance(v1, v2):
	"Returns the distance between two 3d vectors"
	x = v2[0] - v1[0]
	z = v2[2] - v1[2]
	#ignore y value due to the current 13k hack
	return math.sqrt(x * x + z * z)


# ----------------------------------------------------------------------------
# Section: class ElPolloDiablo
# ----------------------------------------------------------------------------
class ElPolloDiablo( BigWorld.Entity ):
	"An ElPolloDiablo entity."

	PATROL_MODE		= 0
	FOLLOW_MODE		= 1

	VELOCITY		= 20

	PATROL_DISTANCE		= 2

	FOLLOW_DISTANCE		= 10
	FOLLOW_ANGLE		= math.pi

	#------------------------------------------------------------------------
	# Constructor
	#------------------------------------------------------------------------

	def __init__( self ):
		BigWorld.Entity.__init__( self )

		# random yaw
		yaw = random.uniform(-math.pi, math.pi)

		self.direction = (0.0, 0.0, yaw)

		if self.mode == ElPolloDiablo.PATROL_MODE:
			self.stopFollow()
		else:
			self.startFollow( self.targetID )

	def onTimer( self, controllerID, userData ):
		self.think()

	def startFollow( self, targetID ):
		self.mode = ElPolloDiablo.FOLLOW_MODE
		self.targetID = targetID
		self.cancel( "Movement" )
		self.think()

	def stopFollow( self ):
		self.mode = ElPolloDiablo.PATROL_MODE
		self.nextNode = None
		self.cancel( "Movement" )
		self.think()

	def think( self ):
		if self.mode == ElPolloDiablo.PATROL_MODE:
			self.patrol()
		else:
			self.follow()


	# Patrol brain
	def patrol( self ):
		# If we haven't got any nodes, find a pair
		if self.nextNode is None:
			self.setupNodes()
		if self.nextNode is None:
			# If we can't find a pair of nodes, wait 5 seconds and try again
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# If we've arrived, turn around
		if self.closeEnoughToNode():
			self.swapNodes()

		# Navigate towards self.nextNode.position
		dest = self.canNavigateTo( self.nextNode.position, 500, 0.5 )
		if dest is None:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return
		self.navigateStep( dest, ElPolloDiablo.VELOCITY, 500, 500, True, 0.5 )

	def closeEnoughToNode( self ):
		target = self.nextNode
		return distance( self.position, target.position ) &lt;= ElPolloDiablo.PATROL_DISTANCE

	def setupNodes( self ):
		self.prevNode = None
		self.nextNode = None
		closest = None
		dist = 500
		for i in BigWorld.userDataObjects.values():
			if i.__class__.__name__ != "PatrolNode" or len(i.patrolLinks) == 0:
				continue
			if distance( self.position, i.position ) &lt; dist:
				closest = i
				dist = distance( self.position, i.position )
		if closest is not None:
			after = closest.patrolLinks[ 0 ]
			while distance( closest.position, after.position ) &lt; ElPolloDiablo.PATROL_DISTANCE * 3:
				after = after.patrolLinks[ 0 ]
				if after is None or after.uuid == closest.uuid:
					after = None
					break
			if after is not None:
				self.prevNode = closest
				self.nextNode = after

	def swapNodes( self ):
		temp = self.nextNode
		self.nextNode = self.prevNode
		self.prevNode = temp

	def onMoveFailure( self, controllerID, userData ):
		# Can't get there. Turn around
		self.swapNodes()
		self.think()

	# Follow brain
	def follow( self ):
		# If self.targetID doesn't exist, switch to patrol mode
		if not BigWorld.entities.has_key( self.targetID ):
			self.stopFollow()
			return

		# If target isn't in this space, switch to patrol mode
		target = BigWorld.entities[ self.targetID ]
		if target.spaceID != self.spaceID:
			self.stopFollow()
			return

		# If we've arrived, wait here for target to move away
		if self.closeEnoughToTarget():
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return

		# Follow our target
		yaw = target.yaw + ElPolloDiablo.FOLLOW_ANGLE
		offset = ( ElPolloDiablo.FOLLOW_DISTANCE * math.sin( yaw ), 0, ElPolloDiablo.FOLLOW_DISTANCE * math.cos( yaw ) )
		dest = self.canNavigateTo( target.position + offset, 500, 0.5 )
		if dest is None:
			# No path found
			self.cancel( "Movement" )
			self.addTimer( 5 )
			return
		self.navigateStep( dest, ElPolloDiablo.VELOCITY, 500, 500, True, 0.5 )

	def closeEnoughToTarget( self ):
		target = BigWorld.entities[ self.targetID ]
		return distance( self.position, target.position ) &lt;= ElPolloDiablo.FOLLOW_DISTANCE

	def onMove( self, controllerID, userData ):
		self.think()

# ElPolloDiablo.py</pre></div></div></div></div></body></html>